<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>有关Java的时间戳问题 | 小彬的博客</title><meta name="author" content="林季彬"><meta name="copyright" content="林季彬"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="背景在做力扣的355题设计推特https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;design-twitter&#x2F;description&#x2F;时，一个主要的功能是要倒序返回一个用户以及他的所关注用户的前十条推文列表。我的做法是设计一个推文类，该类里面有一个成员变量createdTime，在生成一个推文类的时候记录该类生成的时间戳。然后等到返回推文列表的时候用一个TreeSet容器，通过自定义排序规">
<meta property="og:type" content="article">
<meta property="og:title" content="有关Java的时间戳问题">
<meta property="og:url" content="https://xiaobinl.github.io/2023/08/16/%E6%9C%89%E5%85%B3java%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/index.html">
<meta property="og:site_name" content="小彬的博客">
<meta property="og:description" content="背景在做力扣的355题设计推特https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;design-twitter&#x2F;description&#x2F;时，一个主要的功能是要倒序返回一个用户以及他的所关注用户的前十条推文列表。我的做法是设计一个推文类，该类里面有一个成员变量createdTime，在生成一个推文类的时候记录该类生成的时间戳。然后等到返回推文列表的时候用一个TreeSet容器，通过自定义排序规">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.pixabay.com/photo/2023/06/15/17/07/sun-8066051_1280.jpg">
<meta property="article:published_time" content="2023-08-16T09:07:51.000Z">
<meta property="article:modified_time" content="2024-11-30T14:29:33.742Z">
<meta property="article:author" content="林季彬">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="时间戳">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.pixabay.com/photo/2023/06/15/17/07/sun-8066051_1280.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xiaobinl.github.io/2023/08/16/%E6%9C%89%E5%85%B3java%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":60},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '有关Java的时间戳问题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-30 22:29:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.pixabay.com/photo/2023/06/15/17/07/sun-8066051_1280.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="小彬的博客"><span class="site-name">小彬的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">有关Java的时间戳问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-16T09:07:51.000Z" title="发表于 2023-08-16 17:07:51">2023-08-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-30T14:29:33.742Z" title="更新于 2024-11-30 22:29:33">2024-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/">开发进阶</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="有关Java的时间戳问题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在做力扣的355题设计推特<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-twitter/description/">https://leetcode.cn/problems/design-twitter/description/</a><br>时，一个主要的功能是要倒序返回一个用户以及他的所关注用户的前十条推文列表。我的做法是设计一个推文类，该类里面有一个成员变量<code>createdTime</code>，在生成一个推文类的时候记录该类生成的时间戳。然后等到返回推文列表的时候用一个<code>TreeSet</code>容器，通过自定义排序规则来实现按照生成时间倒序返回的目的。其中涉及到Java里面的时间戳的生成。我一开始使用的是<code>System.currentTimeMillis()</code>方法，这个方法返回的是一个毫秒精度的时间戳。但是这样做是有问题的，会卡在：连续调用函数生成推文类的用例那里。当我将代码搬到idea上debug的时候，发现了一个诡异的事情，直接run的时候会出bug，连续生成的两个推文类到最后返回的时候会吞掉一个；但是用debug模式的时候，有时候是正确的输出，有时候又是和run模式一样的错误的输出。一开始我以为是idea的debug模式会比run模式多执行了一些方法的问题（比如idea在debug模式下会自动调用一些集合的<code>toString()</code>方法，用于在debug的时候看到集合里面的内容，但是在run模式下不会），但是后来找很久发现并不是这里面的问题。最后无奈求助了队友才发现是上面提到的推文类里面时间戳的精度不够的问题。</p>
<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>Java里面的<code>System</code>包下的<code>currentTimeMillis()</code>，调用之后返回的是一个以毫秒为精度的时间戳，在Java的源码中该方法的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Returns the current time in milliseconds. Note that while the unit of time of the return value is a millisecond, the granularity of the value depends on the underlying operating system and may be larger. For example, many operating systems measure time in units of tens of milliseconds.</span></span><br><span class="line"><span class="comment">See the description of the class Date for a discussion of slight discrepancies that may arise between &quot;computer time&quot; and coordinated universal time (UTC).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">currentTimeMillis</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是一个<code>long</code>类型的值，表示：当前时间与协调世界时1970年1月1日午夜之间的差值，以毫秒为单位。</p>
<p>但是：<code>System.currentTimeMillis()</code> 虽然返回值的时间单位是毫秒，但值的粒度取决于底层操作系统，在不同操作系统下的实际粒度是不同的。许多操作系统以数十毫秒为单位测量时间。比如：</p>
<ol>
<li><p><strong>Windows 系统：</strong> 在 Windows 操作系统中，默认情况下，<code>System.currentTimeMillis()</code> 的精度通常在 15 毫秒左右，即时间戳的更新间隔可能为 15 毫秒。这是因为 Windows 系统使用多媒体定时器（<code>Multimedia Timer</code>）来提供系统计时服务，而这个定时器的默认分辨率是 15 毫秒。</p>
</li>
<li><p><strong>Linux 系统：</strong> 在 Linux 操作系统中，<code>System.currentTimeMillis()</code> 的实际精度取决于硬件、内核版本和系统配置。一般情况下，Linux 的时间戳精度可以达到几毫秒甚至更低，特别是在支持高分辨率计时器（<code>High-Resolution Timer</code>）的系统上。高分辨率计时器允许纳秒级的时间戳，但是系统配置和硬件支持可能会影响其实际精度。在一些现代的 Linux 发行版中，内核已经支持高分辨率计时器。</p>
</li>
</ol>
<p>因此当发生连续的调用同一个方法的时候，两个方法执行时间之差小于该粒度，那么拿到的时间戳就是相同的，这就导致了后面在用<code>TreeSet</code>容器按照时间戳进行排序的时候会将其中一个去重处理，这就解释了上面的直接run会出错，但是debug模式下，在将断点打在方法内的时候，由于此时两个方法的调用时间被隔开了，因此这时拿到的时间戳就是不同的，进而没有问题的这一诡异现象。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>上面的问题是由于<code>System.currentTimeMillis()</code> 方法获取的时间戳粒度不够导致的，当连续两个方法调用的时间间隔小于该方法的粒度的时候，该方法拿到的是两个相同的时间戳，然后再使用<code>TreeSet</code>进行处理的时候，由于<code>TreeSet</code>容器的特性，会将时间戳相同的去重处理，因此解决方法也很简单，换一个更高精度的时间戳就可以了。一般认为达到纳秒级的时间精度就足以表示两个方法调用之间的最小时间间隔了，但是并不绝对，具体的还是要看不同的操作系统、硬件、方法调用开销以及可能的线程竞争等方面。但是在这里，我们只要将获取的时间戳的精度提高到纳秒级就可以了。</p>
<h1 id="Java的时间戳获取"><a href="#Java的时间戳获取" class="headerlink" title="Java的时间戳获取"></a>Java的时间戳获取</h1><p>一般我们获取时间戳的时候通常有以下这几种方式：</p>
<ol>
<li><p><code>System.currentTimeMillis()</code> 方法：返回的是一个<code>long</code>类型的值，表示：当前时间与协调世界时1970年1月1日午夜之间的差值，以毫秒为单位。</p>
</li>
<li><p><code>new Date().getTime()</code>方法：该方法的底层其实还是调用的<code>System.currentTimeMillis()</code> 方法，其源码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Calendar.getInstance().getTimeInMillis()</code>方法：也是返回此日历的时间值（以毫秒为单位）。</p>
</li>
</ol>
<p>上面的三个返回的都是以毫秒值为单位的时间戳，但是他们在效率上还是有差异的：</p>
<ul>
<li><code>System.currentTimeMillis()</code> 方法是调用本地方法，且是静态方法，不需要创建对象，因此是最快的；</li>
<li>通过<code>new Date().getTime()</code>方法获取时间戳，它的底层还是调用的<code>System.currentTimeMillis()</code> 方法，但是要创建Date对象，因此效率比不上<code>System.currentTimeMillis()</code> ；</li>
<li><code>Calendar.getInstance().getTimeInMillis()</code>方法由于考虑的因素比较多（比如考虑了时区的影响）因此在效率上表现最差。</li>
</ul>
<h1 id="精度更高的时间戳的获取"><a href="#精度更高的时间戳的获取" class="headerlink" title="精度更高的时间戳的获取"></a>精度更高的时间戳的获取</h1><p>上面的三种获取时间戳的方法都是只能获取到毫秒精度的时间戳，这里的毫秒级精度并不是说两个值之间最小相差1毫秒，事实上有些系统的粒度甚至是几十毫秒。那我们想要获取到精度更高的时间戳（比如纳秒级的精度的时间戳）怎么办呢？</p>
<p>下面介绍两个我目前知道的方法。</p>
<h2 id="通过System-nanoTime-方法"><a href="#通过System-nanoTime-方法" class="headerlink" title="通过System.nanoTime()方法"></a>通过System.nanoTime()方法</h2><p>在System类的<code>currentTimeMillis()</code>这个方法的下面紧接着就定义着一个<code>nanoTime()</code>方法，该方法返回的是当前时间与某个特定起点时间之间的纳秒数差。它通常用于计算不同时间片段之间的时间差，而不是作为全局唯一的时间戳。在源码中是这样定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Returns the current value of the running Java Virtual Machine&#x27;s high-resolution time source, in nanoseconds.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time. The value returned represents nanoseconds since some fixed but arbitrary origin time (perhaps in the future, so values may be negative). The same origin is used by all invocations of this method in an instance of a Java virtual machine; other virtual machine instances are likely to use a different origin.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This method provides nanosecond precision, but not necessarily nanosecond resolution (that is, how frequently the value changes) - no guarantees are made except that the resolution is at least as good as that of currentTimeMillis().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Differences in successive calls that span greater than approximately 292 years (263 nanoseconds) will not correctly compute elapsed time due to numerical overflow.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The values returned by this method become meaningful only when the difference between two such values, obtained within the same instance of a Java virtual machine, is computed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">For example, to measure how long some code takes to execute:</span></span><br><span class="line"><span class="comment">  long startTime = System.nanoTime();   // ... the code being measured ...   </span></span><br><span class="line"><span class="comment">  long estimatedTime = System.nanoTime() - startTime;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">To compare two nanoTime values</span></span><br><span class="line"><span class="comment">  long t0 = System.nanoTime();   ...   </span></span><br><span class="line"><span class="comment">  long t1 = System.nanoTime();</span></span><br><span class="line"><span class="comment">one should use t1 - t0 &lt; 0, not t1 &lt; t0, because of the possibility of numerical overflow.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nanoTime</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>根据上面的定义的注释，在使用这个方法之前要注意以下的几个方面：</p>
<ol>
<li>关于返回值：返回正在运行的Java虚拟机的高分辨率时间源的当前值，单位为纳秒。但是和<code>currentTimeMillis()</code>一样，虽然是纳秒级的精度，但并不意味着最小两个值之间的差是1纳秒。除了保证能提供比<code>currentTimeMillis()</code>方法更高的精度之外，并不保证返回的两个值之间的任何关系。</li>
<li>这种方法只能用于测量经过的时间，与系统或挂钟时间的任何其他概念无关。返回的值表示自某个固定但任意的起始时间（时间原点）以来的纳秒（可能在将来，因此值可能为负数）。在Java虚拟机的实例中，此方法的所有调用都使用相同的原点；其他虚拟机实例可能使用不同的来源。</li>
<li>由于数值溢出的问题，跨度超过约292年，或者小于263纳秒的连续调用之间的差异将无法正确计算所用时间。</li>
</ol>
<h2 id="java-time-包下的-Instant-类"><a href="#java-time-包下的-Instant-类" class="headerlink" title="java.time 包下的 Instant 类"></a>java.time 包下的 <code>Instant</code> 类</h2><p>Java 8 引入的 <code>java.time</code> 包提供了更强大且易于使用的工具。<code>Instant</code> 类是其中的一部分，用于表示时间轴上的一个特定瞬时点，而且提供了以毫秒和纳秒为单位的时间戳。下面我将详细介绍 <code>Instant</code> 类的创建、使用以及与其他方法的对比。</p>
<h3 id="创建-Instant-实例："><a href="#创建-Instant-实例：" class="headerlink" title="创建 Instant 实例："></a><strong>创建 Instant 实例：</strong></h3><p> 创建 <code>Instant</code> 实例非常简单，可以使用静态方法 <code>Instant.now()</code> 获取当前的时间点。也可以通过提供秒数和纳秒数来创建一个特定的瞬时点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间的 Instant</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定时间点的 Instant</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">specificInstant</span> <span class="operator">=</span> Instant.ofEpochSecond(seconds, nanos);</span><br></pre></td></tr></table></figure>

<h3 id="获取时间戳："><a href="#获取时间戳：" class="headerlink" title="获取时间戳："></a><strong>获取时间戳：</strong></h3><p><code>Instant</code> 实例提供了两种方式获取时间戳，分别是毫秒值和纳秒值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">timestampMillis</span> <span class="operator">=</span> instant.toEpochMilli(); <span class="comment">// 获取毫秒级别的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">timestampNanos</span> <span class="operator">=</span> instant.getNano(); <span class="comment">// 获取纳秒级别的时间戳</span></span><br></pre></td></tr></table></figure>

<h3 id="与其他方法的对比："><a href="#与其他方法的对比：" class="headerlink" title="与其他方法的对比："></a><strong>与其他方法的对比：</strong></h3><p><code>Instant</code> 类在 <code>java.time</code> 包中是一个非常有用的工具，用于表示高精度的时间戳和瞬时点。它在许多方面比传统的时间处理方法更优越，尤其是在精度、易用性和线程安全性方面。在与其他时间处理方法对比时，<code>Instant</code> 类在精度和易用性方面都有优势。</p>
<ul>
<li>与 <code>System.currentTimeMillis()</code> 对比：<code>Instant</code> 类提供了更高精度的时间戳，可以获取纳秒级别的时间戳，而不仅仅是毫秒。同时，<code>Instant</code> 是不依赖于操作系统精度的。</li>
<li>与 <code>System.nanoTime()</code> 对比：<code>Instant</code> 类的 <code>getNano()</code> 方法可以用来获取当前纳秒值，类似于 <code>System.nanoTime()</code>，但需要注意 <code>System.nanoTime()</code> 更适合用于测量时间间隔，而不是绝对时间点。</li>
<li>与 <code>Date</code> 和 <code>Calendar</code> 对比：<code>Instant</code> 是 <code>java.time</code> 包的一部分，与传统的 <code>Date</code> 和 <code>Calendar</code> 相比，它更加现代且线程安全，同时提供了更好的易用性和精度。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xiaobinl.github.io">林季彬</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xiaobinl.github.io/2023/08/16/%E6%9C%89%E5%85%B3java%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/">https://xiaobinl.github.io/2023/08/16/%E6%9C%89%E5%85%B3java%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xiaobinl.github.io" target="_blank">小彬的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%97%B6%E9%97%B4%E6%88%B3/">时间戳</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.pixabay.com/photo/2023/06/15/17/07/sun-8066051_1280.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/08/17/%E5%AF%B9%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/" title="对于面向对象思想的理解"><img class="cover" src="https://cdn.pixabay.com/photo/2023/08/03/19/34/catholic-church-8167850_1280.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">对于面向对象思想的理解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/10/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86/" title="动态代理的原理"><img class="cover" src="https://cdn.pixabay.com/photo/2023/08/16/18/05/homes-8194751_1280.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-10</div><div class="title">动态代理的原理</div></div></a></div><div><a href="/2024/06/08/Spring%E9%A1%B9%E7%9B%AE%E8%AF%BB%E5%8F%96%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/" title="Spring项目读取静态资源文件的方法"><img class="cover" src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-08</div><div class="title">Spring项目读取静态资源文件的方法</div></div></a></div><div><a href="/2023/08/29/%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3/" title="反射相关"><img class="cover" src="https://cdn.pixabay.com/photo/2023/02/07/18/56/rocket-7774875_1280.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-29</div><div class="title">反射相关</div></div></a></div><div><a href="/2023/08/17/%E5%AF%B9%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/" title="对于面向对象思想的理解"><img class="cover" src="https://cdn.pixabay.com/photo/2023/08/03/19/34/catholic-church-8167850_1280.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-17</div><div class="title">对于面向对象思想的理解</div></div></a></div><div><a href="/2023/08/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="线程池的创建与使用"><img class="cover" src="https://cdn.pixabay.com/photo/2023/08/24/21/10/ai-generated-8211648_1280.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-28</div><div class="title">线程池的创建与使用</div></div></a></div><div><a href="/2024/06/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9B%B8%E5%85%B3/" title="布隆过滤器相关"><img class="cover" src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-07</div><div class="title">布隆过滤器相关</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Livere</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODg4Ny8zNTM0OQ=="></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">林季彬</div><div class="author-info__description">欢迎来到我的博客。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="[&quot;https://github.com/XiaobinL&quot;,&quot;https://gitee.com/L_XiaoBin&quot;]"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XiaobinL" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:linjibin@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">发现问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E8%8E%B7%E5%8F%96"><span class="toc-number">4.</span> <span class="toc-text">Java的时间戳获取</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B2%BE%E5%BA%A6%E6%9B%B4%E9%AB%98%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">5.</span> <span class="toc-text">精度更高的时间戳的获取</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87System-nanoTime-%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">通过System.nanoTime()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-time-%E5%8C%85%E4%B8%8B%E7%9A%84-Instant-%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">java.time 包下的 Instant 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Instant-%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">创建 Instant 实例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">获取时间戳：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">5.2.3.</span> <span class="toc-text">与其他方法的对比：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B--%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="设计模式之--策略模式"><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/refs/heads/main/img/DesignPattern/%E7%AD%96%E7%95%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%81%E9%9D%A2.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式之--策略模式"/></a><div class="content"><a class="title" href="/2025/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B--%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="设计模式之--策略模式">设计模式之--策略模式</a><time datetime="2025-05-27T12:24:03.000Z" title="发表于 2025-05-27 20:24:03">2025-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/30/hello-world/" title="Hello World"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2024/11/30/hello-world/" title="Hello World">Hello World</a><time datetime="2024-11-30T14:29:33.740Z" title="发表于 2024-11-30 22:29:33">2024-11-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/08/easyexcel%E5%86%99%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AE%B9%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/" title="easyexcel写文件如何控制单元格的格式以及内容的格式化"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="easyexcel写文件如何控制单元格的格式以及内容的格式化"/></a><div class="content"><a class="title" href="/2024/06/08/easyexcel%E5%86%99%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AE%B9%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/" title="easyexcel写文件如何控制单元格的格式以及内容的格式化">easyexcel写文件如何控制单元格的格式以及内容的格式化</a><time datetime="2024-06-07T17:29:42.000Z" title="发表于 2024-06-08 01:29:42">2024-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/08/Spring%E9%A1%B9%E7%9B%AE%E8%AF%BB%E5%8F%96%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/" title="Spring项目读取静态资源文件的方法"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring项目读取静态资源文件的方法"/></a><div class="content"><a class="title" href="/2024/06/08/Spring%E9%A1%B9%E7%9B%AE%E8%AF%BB%E5%8F%96%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/" title="Spring项目读取静态资源文件的方法">Spring项目读取静态资源文件的方法</a><time datetime="2024-06-07T17:28:16.000Z" title="发表于 2024-06-08 01:28:16">2024-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9B%B8%E5%85%B3/" title="布隆过滤器相关"><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="布隆过滤器相关"/></a><div class="content"><a class="title" href="/2024/06/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9B%B8%E5%85%B3/" title="布隆过滤器相关">布隆过滤器相关</a><time datetime="2024-06-07T15:05:09.000Z" title="发表于 2024-06-07 23:05:09">2024-06-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023.08 - 2025 By 林季彬</div><div class="footer_custom_text">很高兴认识你~~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'https://xiaobinl.github.io/2023/08/16/%E6%9C%89%E5%85%B3java%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/'
    this.page.identifier = '/2023/08/16/%E6%9C%89%E5%85%B3java%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/'
    this.page.title = '有关Java的时间戳问题'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Livere' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>