<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式之--策略模式</title>
      <link href="/2025/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B--%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B--%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>以下是本人在学习设计模式的过程中的一些笔记和代码.下面的内容主要是在看完了B站视频: <a href="https://www.bilibili.com/video/BV1HA7RzDEuz?spm_id_from=333.788.videopod.sections&vd_source=8888a34cb3b0988d5e85f2302b216163">策略模式</a> 之后的笔记总结.<br>策略模式一般用来优化if-else结构,减少if-else层级,是的代码的可读性增加,那么策略模式究竟是怎么样优化if-else结构的呢?下面展示的是一个使用策略模式优化一段if-else结构,一步一步思考逻辑.</p><h2 id="Version1"><a href="#Version1" class="headerlink" title="Version1"></a>Version1</h2><p>先看下面的一段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version1.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/customer/v1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerControllerV1</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;recharge&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">customer</span><span class="params">(<span class="meta">@PathVariable(value = &quot;recharge&quot;)</span> Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (recharge &gt;<span class="number">0</span> &amp;&amp; recharge &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;普通玩家客服&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recharge &gt; <span class="number">100</span> &amp;&amp; recharge &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">            <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;VIP玩家客服&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recharge &gt; <span class="number">10_000</span> &amp;&amp; recharge &lt;= <span class="number">100_000</span>) &#123;</span><br><span class="line">            <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;VVIP玩家客服&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recharge &gt; <span class="number">100_000</span> &amp;&amp; recharge &lt;= <span class="number">1_000_000</span>) &#123;</span><br><span class="line">            <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;SVIP玩家客服&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recharge &gt; <span class="number">1_000_000</span>) &#123;</span><br><span class="line">            <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;专属客服&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;找不到客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个对外接口,传进来一个充值金额,根据充值金额返回对应的客服.(一般来说不建议在controller层直接写逻辑,但是这里只是为了演示,不做过多无意义的封装).</p><p>每一个初学者都很简单能够写出这个逻辑.但是这样写的问题就是,如果充值金额大于1_000_000的时候,需要新增一个档位,那么就需要修改流程代码,强行插入逻辑,这不符合开闭原则,并且如果每一个if分支立里面的代码逻辑很长,这会导致代码可读性很差.<br>这段代码的重点在两个方面,一个是每个分支里面的逻辑,这里是如何获取相应的客服,另一个是判断条件,也就是判断什么时候进入什么分支,对于这种情况就非常适合使用策略模式来进行优化.</p><h2 id="Version2"><a href="#Version2" class="headerlink" title="Version2"></a>Version2</h2><p>策略模式最主要的两点,分别对应着上面提到的两个重点.每个分支结构都是一个策略,每种策略都有进入条件,根据条件判断进入哪个分支.<br>策略模式一般会定义一个策略接口,定义策略的抽象方法,然后定义策略实现类,实现策略接口,并实现抽象方法.</p><p>这里首先定义一个策略接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName:CustomerService</span></span><br><span class="line"><span class="comment"> * Package: org.lin.strategicdesignpattern.version2</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2025/5/26 22:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerServiceV2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里定义进入每个策略的条件,让每个策略自己写自己的条件</span></span><br><span class="line"><span class="comment">     * @param recharge</span></span><br><span class="line"><span class="comment">     * @return java.lang.Boolean</span></span><br><span class="line"><span class="comment">     * @author Xiaobin</span></span><br><span class="line"><span class="comment">     * @since 2025/05/26 22:49</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Boolean <span class="title function_">support</span><span class="params">(Integer recharge)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里定义每个策略的具体逻辑</span></span><br><span class="line"><span class="comment">     * @param recharge</span></span><br><span class="line"><span class="comment">     * @return java.lang.String</span></span><br><span class="line"><span class="comment">     * @author Xiaobin</span></span><br><span class="line"><span class="comment">     * @since 2025/05/26 22:41</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个策略接口里面定义了两个事情,一个是判断进入这个策略的条件,一个是每个策略的具体逻辑.策略接口定义好了之后开始写策略实现类,对应上面一个if分支结构一个具体的策略实现类.</p><p>普通玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 控制加载的顺序,优先级比默认高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalCustomerServiceV2Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">support</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recharge &gt;<span class="number">0</span> &amp;&amp; recharge &lt;= <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;普通玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VIP玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SVIP玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 控制加载的顺序,优先级比默认高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SVIPCustomerServiceV2Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV2</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">support</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recharge &gt; <span class="number">100_000</span> &amp;&amp; recharge &lt;= <span class="number">1_000_000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SVIP玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SVIP玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SVIP玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 控制加载的顺序,优先级比默认高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SVIPCustomerServiceV2Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV2</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">support</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recharge &gt; <span class="number">100_000</span> &amp;&amp; recharge &lt;= <span class="number">1_000_000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SVIP玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VVIP玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VVIP玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 控制加载的顺序,优先级比默认高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VVIPCustomerServiceV2Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV2</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">support</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recharge &gt; <span class="number">10_000</span> &amp;&amp; recharge &lt;= <span class="number">100_000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;VVIP玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>专属玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 专属玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 控制加载的顺序,优先级比默认高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExclusiveCustomerServiceV2Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">support</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recharge &gt; <span class="number">1_000_000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;专属客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的找不到客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 23:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultCustomerServiceV2Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV2</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">support</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;找不到客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了6个策略实现类,继承于策略接口,然后分别实现自己的逻辑.<br>然后我们就可以在程序里面引入所有的实现类,动态判断走哪个实现类,然后执行那个实现类的逻辑.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/customer/v2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerControllerV2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有实现了CustomerService接口的类都注入到customerServiceList中</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;CustomerServiceV2&gt; customerServiceV2List;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&#123;recharge&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">customer</span><span class="params">(<span class="meta">@PathVariable(value = &quot;recharge&quot;)</span> Integer recharge)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历customerServiceList，找到第一个支持的类,然后调用findCustomer方法</span></span><br><span class="line">        <span class="keyword">for</span> (CustomerServiceV2 customerServiceV2 : customerServiceV2List) &#123;</span><br><span class="line">            <span class="keyword">if</span> (customerServiceV2.support(recharge)) &#123;</span><br><span class="line">                <span class="keyword">return</span> customerServiceV2.findCustomer(recharge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为上面的customerServiceList中已经添加了默认的客服,默认客服的support方法返回true,所以正常执行的话就不会执行到这一步</span></span><br><span class="line">        <span class="comment">// 所以如果执行到之里,说明程序异常了,这里抛出异常即可</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;没有找到对应的客服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用策略模式优化上面的代码,将不同的策略都注入到一个集合中,然后动态判断执行哪个策略<br>这个时候如果我们需要添加一个客服,只需要在CustomerService接口中添加一个实现类,然后写上该实现类自己的判断进入条件,和该实现类自己的逻辑,然后注入到customerServiceList中,就可以调用该实现类的逻辑,不再需要改主流程的代码</p><p>但是这里有一个问题点,就是策略的顺序问题<br>因为有默认客服的实现,但是默认客服实现类加载的顺序默认不可控,下面进行for循环的时候如果默认客服实现类加载的顺序不是最后面,那么就会执行默认的客服实现类的逻辑,而不是执行对应的客服<br>这里需要对customerServiceList里面的各个策略的顺序进行控制,因为除了默认的策略外,其余的策略进入的条件都是互斥的,所以其余策略的相互顺序并不重要,重要的只是默认的策略必须排在所有策略最后即可<br>那么如何控制注入的这个list里面每种策略的顺序呢?<br>使用@Order注解,控制不同策略加载的顺序,默认的策略加载的优先级最低,最后加载,排在最后<br>@Order(value) value越小的优先级越高.</p><p>其实到这一步已经是使用了策略模式了,并且看起来这个策略模式是不错的.但是还能不能再优化一点呢?<br>这里的优化点可以有下面的两个方向考虑:</p><ol><li>当前各个策略的进入条件是各自持有的,分散在了各自的实现类中,这里考虑将条件集中管理;</li><li>当前这里是将所有的实现类以一个List的方式注入,然后每次执行的时候通过遍历这个List来找到对应的策略实现类.一般来讲这里的时间复杂度是O(n),还能有优化的空间.这里考虑通过工厂模式,在容器启动的时候加载所有的策略到工厂中,从工厂类中获取对应的策略实现类,然后执行对应的策略实现类.</li></ol><h2 id="Version3"><a href="#Version3" class="headerlink" title="Version3"></a>Version3</h2><p>首先考虑第一点,我们使用一个枚举,将所有的判断逻辑集中起来:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName:UserTypeEnum</span></span><br><span class="line"><span class="comment"> * Package: org.lin.strategicdesignpattern.version4</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2025/5/26 23:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserTypeEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;普通用户&quot;</span>, recharge -&gt; recharge &gt;<span class="number">0</span> &amp;&amp; recharge &lt;= <span class="number">100</span>),</span><br><span class="line">    VIP(<span class="number">2</span>, <span class="string">&quot;VIP用户&quot;</span>, recharge -&gt; recharge &gt; <span class="number">100</span> &amp;&amp; recharge &lt;= <span class="number">10000</span>),</span><br><span class="line">    VVIP(<span class="number">3</span>, <span class="string">&quot;VVIP用户&quot;</span>, recharge -&gt; recharge &gt; <span class="number">10_000</span> &amp;&amp; recharge &lt;= <span class="number">100_000</span>),</span><br><span class="line">    SVIP(<span class="number">4</span>, <span class="string">&quot;SVIP用户&quot;</span>, recharge -&gt; recharge &gt; <span class="number">100_000</span> &amp;&amp; recharge &lt;= <span class="number">1_000_000</span>),</span><br><span class="line">    EXCLUSIVE(<span class="number">5</span>, <span class="string">&quot;专属用户&quot;</span>, recharge -&gt; recharge &gt; <span class="number">1_000_000</span>),</span><br><span class="line">    DEFAULT(<span class="number">6</span>, <span class="string">&quot;默认用户&quot;</span>, recharge -&gt;  Boolean.FALSE),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;Integer, Boolean&gt; support;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserTypeEnum <span class="title function_">getUserTypeEnum</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(UserTypeEnum.values())</span><br><span class="line">                .filter(userType -&gt; userType.support.apply(recharge))</span><br><span class="line">                .findFirst().orElse(DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个枚举里面每一个枚举量都有自己条件逻辑,然后在下面的策略实现类里面持有自己的枚举值,通过策略实现类 –&gt;  枚举值 –&gt; 枚举值对应的判断条件 这样的形式关联起来.</p><p>然后一样的,我们定义策略接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName:CustomerService</span></span><br><span class="line"><span class="comment"> * Package: org.lin.strategicdesignpattern.version2</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2025/5/26 22:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerServiceV4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取用户类型</span></span><br><span class="line"><span class="comment">     * @return org.lin.strategicdesignpattern.version4.UserTypeEnum</span></span><br><span class="line"><span class="comment">     * @author Xiaobin</span></span><br><span class="line"><span class="comment">     * @since 2025/05/26 22:41</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UserTypeEnum <span class="title function_">getUserType</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里定义每个策略的具体逻辑</span></span><br><span class="line"><span class="comment">     * @param recharge</span></span><br><span class="line"><span class="comment">     * @return java.lang.String</span></span><br><span class="line"><span class="comment">     * @author Xiaobin</span></span><br><span class="line"><span class="comment">     * @since 2025/05/26 22:41</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口将Version2里面的support方法进行了修改,原本的support方法里面放的是各个策略实现类进入的判断条件,这里将由于将判断条件集中到了枚举类里面,所以需要让策略实现类持有枚举值,然后通过枚举值来让判断条件和策略实现类关联起来.</p><p>然后我们实现策略的实现类</p><p>普通玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalCustomerServiceV4Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserTypeEnum <span class="title function_">getUserType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserTypeEnum.NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;普通玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VIP玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VIP玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VIPCustomerServiceV4Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV4</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserTypeEnum <span class="title function_">getUserType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserTypeEnum.VIP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;VIP玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SVIP玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SVIP玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SVIPCustomerServiceV4Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV4</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserTypeEnum <span class="title function_">getUserType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserTypeEnum.SVIP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SVIP玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VVIP玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VVIP玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VVIPCustomerServiceV4Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV4</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserTypeEnum <span class="title function_">getUserType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserTypeEnum.VVIP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;VVIP玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>专属玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 专属玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExclusiveCustomerServiceV4Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserTypeEnum <span class="title function_">getUserType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserTypeEnum.EXCLUSIVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;专属客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的找不到客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 23:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultCustomerServiceV4Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV4</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserTypeEnum <span class="title function_">getUserType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;找不到客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们考虑上面的第二点,引入工厂模式,创建一个策略工厂.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略模式实现类工厂类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/27 00:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerServiceFactory</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;UserTypeEnum, CustomerServiceV4&gt; SERVICE_MAP;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext; <span class="comment">// 静态保存上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CustomerServiceV4 <span class="title function_">getService</span><span class="params">(UserTypeEnum userTypeEnum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SERVICE_MAP.getOrDefault(userTypeEnum, getDefaultCustomerService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 从容器中获取全部的支付处理类，注册到map中</span></span><br><span class="line">        Map&lt;String, CustomerServiceV4&gt; customerServiceV4s = applicationContext.getBeansOfType(CustomerServiceV4.class);</span><br><span class="line">        SERVICE_MAP = customerServiceV4s.values().stream().filter(customerServiceV4 -&gt; customerServiceV4.getUserType() != <span class="literal">null</span>)</span><br><span class="line">                .collect(Collectors.toConcurrentMap(CustomerServiceV4::getUserType, Function.identity()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器中获取默认实现</span></span><br><span class="line">    <span class="keyword">private</span> CustomerServiceV4 <span class="title function_">getDefaultCustomerService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(<span class="string">&quot;defaultCustomerServiceV4Impl&quot;</span>, CustomerServiceV4.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建一个工厂类,在容器初始化的时候,获取到所有的策略实现类,并且注册到map中,通过用户类型获取对应的策略实现类.</p><p>然后我们主流程就可以简化成下面这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/customer/v4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerControllerV4</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CustomerServiceFactory customerServiceFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&#123;recharge&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">customer</span><span class="params">(<span class="meta">@PathVariable(value = &quot;recharge&quot;)</span> Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> customerServiceFactory.getService(UserTypeEnum.getUserTypeEnum(recharge)).findCustomer(recharge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到的逻辑很清晰,首先根据充值金额判断拿到对应的用户类型,然后根据客户类型从工厂类中获取提前注册好的策略实现类,然后调用对应的策略实现类中的方法<br>这里优化的点有两点:</p><ol><li>将条件判断逻辑集中到一个地方,即UserTypeEnum,然后每个策略分配一个UserType</li><li>通过工厂模式,在容器启动的时候加载所有的策略到工厂中,然后根据条件判断进入哪个策略</li></ol><p>到这里我们想能不能再简化一点呢?<br>策略模式应该只保留本身各自逻辑,但是这里却引入和另外的一个概念就是用户类型,策略实现类需要持有用户类型,但是持有的实现方法有很多种,之类考虑使用注解的方式持有.把用户类型抽出来写成一个注解的形式,然后通过扫描注解的方式,将注解的策略注册到工厂中,然后根据条件判断进入哪个策略.</p><h2 id="Version4"><a href="#Version4" class="headerlink" title="Version4"></a>Version4</h2><p>首先定义一个SupportUserType注解,这个注解可以加在类上面,在运行时生效,注解里面有一个UserType枚举的属性,表示当前类属于哪个UserType.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName:SupportUserType</span></span><br><span class="line"><span class="comment"> * Package: org.lin.strategicdesignpattern.version5</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2025/5/27 01:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SupportUserType &#123;</span><br><span class="line"></span><br><span class="line">    UserTypeEnumV5 <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的,我们需要定义一个策略接口,如下,但是在这个接口里面不需要再显式地对策略进入条件进行抽象了,同时也不需要再定义策略实现类的用户方法,我们将这部份的内容,放到注解里面去:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName:CustomerService</span></span><br><span class="line"><span class="comment"> * Package: org.lin.strategicdesignpattern.version2</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2025/5/26 22:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerServiceV5</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里定义每个策略的具体逻辑</span></span><br><span class="line"><span class="comment">     * @param recharge</span></span><br><span class="line"><span class="comment">     * @return java.lang.String</span></span><br><span class="line"><span class="comment">     * @author Xiaobin</span></span><br><span class="line"><span class="comment">     * @since 2025/05/26 22:41</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的注解中持有一个UserType类型的枚举,这里同样需要将这个枚举定义出来:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName:UserTypeEnum</span></span><br><span class="line"><span class="comment"> * Package: org.lin.strategicdesignpattern.version4</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2025/5/26 23:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserTypeEnumV5</span> &#123;</span><br><span class="line"></span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;普通用户&quot;</span>, recharge -&gt; recharge &gt;<span class="number">0</span> &amp;&amp; recharge &lt;= <span class="number">100</span>),</span><br><span class="line">    VIP(<span class="number">2</span>, <span class="string">&quot;VIP用户&quot;</span>, recharge -&gt; recharge &gt; <span class="number">100</span> &amp;&amp; recharge &lt;= <span class="number">10000</span>),</span><br><span class="line">    VVIP(<span class="number">3</span>, <span class="string">&quot;VVIP用户&quot;</span>, recharge -&gt; recharge &gt; <span class="number">10_000</span> &amp;&amp; recharge &lt;= <span class="number">100_000</span>),</span><br><span class="line">    SVIP(<span class="number">4</span>, <span class="string">&quot;SVIP用户&quot;</span>, recharge -&gt; recharge &gt; <span class="number">100_000</span> &amp;&amp; recharge &lt;= <span class="number">1_000_000</span>),</span><br><span class="line">    EXCLUSIVE(<span class="number">5</span>, <span class="string">&quot;专属用户&quot;</span>, recharge -&gt; recharge &gt; <span class="number">1_000_000</span>),</span><br><span class="line">    DEFAULT(<span class="number">6</span>, <span class="string">&quot;默认用户&quot;</span>, recharge -&gt;  Boolean.FALSE),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;Integer, Boolean&gt; support;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserTypeEnumV5 <span class="title function_">getUserTypeEnum</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(UserTypeEnumV5.values())</span><br><span class="line">                .filter(userType -&gt; userType.support.apply(recharge))</span><br><span class="line">                .findFirst().orElse(DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来依旧是需要定义几个策略实现类,这里通过在实现类上标注我们自定义的注解的方式 ,将策略实现类和用户类型进行绑定,进而和进入条件绑定.</p><p>普通玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SupportUserType(UserTypeEnumV5.NORMAL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalCustomerServiceV5Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;普通玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VIP玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VIP玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SupportUserType(UserTypeEnumV5.VIP)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VIPCustomerServiceV5Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;VIP玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VVIP玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VVIP玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SupportUserType(UserTypeEnumV5.VVIP)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VVIPCustomerServiceV5Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;VVIP玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SVIP玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SVIP玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SupportUserType(UserTypeEnumV5.SVIP)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SVIPCustomerServiceV5Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SVIP玩家客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>专属玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.lin.strategicdesignpattern.version4.UserTypeEnum;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 专属玩家客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 22:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SupportUserType(UserTypeEnumV5.EXCLUSIVE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExclusiveCustomerServiceV5Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV5</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="comment">// ....一些其他的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;专属客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认玩家客服策略实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的找不到客服实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/26 23:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@SupportUserType(UserTypeEnumV5.DEFAULT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultCustomerServiceV5Impl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceV5</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findCustomer</span><span class="params">(Integer recharge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;找不到客服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要一个策略工厂,在容器初始化的时候将所有的策略实现类加载到工厂中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lin.strategicdesignpattern.version5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.support.AopUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.EnumMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略模式实现类工厂类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/05/27 00:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerServiceFactoryV5</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;UserTypeEnumV5, CustomerServiceV5&gt; SERVICE_MAP = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(UserTypeEnumV5.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext; <span class="comment">// 静态保存上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CustomerServiceV5 <span class="title function_">getService</span><span class="params">(UserTypeEnumV5 userTypeEnumV5)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SERVICE_MAP.getOrDefault(userTypeEnumV5, getDefaultCustomerService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 从容器中获取全部的支付处理类，注册到map中</span></span><br><span class="line">        Map&lt;String, CustomerServiceV5&gt; customerServiceV5s = applicationContext.getBeansOfType(CustomerServiceV5.class);</span><br><span class="line">        customerServiceV5s.values().stream().filter(customerServiceV5 -&gt; customerServiceV5.getClass().isAnnotationPresent(SupportUserType.class))</span><br><span class="line">                .forEach(customerServiceV5 -&gt; SERVICE_MAP.put(AopUtils.getTargetClass(customerServiceV5).getAnnotation(SupportUserType.class).value(), customerServiceV5));</span><br><span class="line">        <span class="keyword">if</span> (SERVICE_MAP.size() != UserTypeEnumV5.values().length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请检查是否注册了所有的策略类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器中获取默认实现</span></span><br><span class="line">    <span class="keyword">private</span> CustomerServiceV5 <span class="title function_">getDefaultCustomerService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(<span class="string">&quot;defaultCustomerServiceV5Impl&quot;</span>, CustomerServiceV5.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于将每个策略实现类的用户类型放在了注解里面,所以工厂里面加载所有实现类的方法也要对应这个改变,这里通过AopUtils.getTargetClass(customerServiceV5).getAnnotation(SupportUserType.class)来获取每个策略实现类上SupportUserType注解,而不是通过customerService.getClass().getAnnotation(SupportUserType.class),是因为考虑到策略实现类有可能被代理,一旦策略实现类被代理的话,后者可能会获取不到.<br>同时这里将存放策略实现类的容器由ConcurrentHashMap换成了EnumMap,进一步提升性能.<br>EnumMap 是 Java 集合框架中的一种特殊实现类，它是一个基于枚举类型的键（key）的 Map 实现。其内部使用数组存储值，使得其性能优于 HashMap 和 ConcurrentHashMap，尤其是在键是枚举类型时。<br>特点:</p><ol><li>键必须为枚举类型：EnumMap 的键只能是枚举类型（Enum），不能是其他类型。</li><li>高性能：由于底层采用数组实现，访问速度比哈希表更快。</li><li>有序性：EnumMap 保持键的自然顺序（即枚举常量声明的顺序）。</li><li>线程不安全：与 HashMap 一样，EnumMap 不是线程安全的。如果需要并发访问，可以使用 Collections.synchronizedMap() 进行包装。</li></ol><p>虽然第4点提到EnumMap是线程不安全的,但是由于这个场景里,工厂的初始化发生在容器启动阶段,并且在初始化完成之后,后续是只读的,所以这里并没有线程安全问题.</p>]]></content>
      
      
      <categories>
          
          <category> 开发进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/11/30/hello-world/"/>
      <url>/2024/11/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>easyexcel写文件如何控制单元格的格式以及内容的格式化</title>
      <link href="/2024/06/08/easyexcel%E5%86%99%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AE%B9%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/2024/06/08/easyexcel%E5%86%99%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AE%B9%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>待更新。。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring项目读取静态资源文件的方法</title>
      <link href="/2024/06/08/Spring%E9%A1%B9%E7%9B%AE%E8%AF%BB%E5%8F%96%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2024/06/08/Spring%E9%A1%B9%E7%9B%AE%E8%AF%BB%E5%8F%96%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>待更新。。。</p>]]></content>
      
      
      <categories>
          
          <category> 开发相关积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器相关</title>
      <link href="/2024/06/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/06/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>如果想要快速判断一个元素是不是在一个集合里，可以怎么做？<br>一般想到的是用一种数据结构将所有元素保存起来，然后通过比较确定。<br>数组，链表，树等等数据结构都是这种思路.<br>但是随着集合中元素的增加，使用数组链表等结构，我们需要的存储空间越来越大，检索速度也越来越慢(<code>O(n),O(logn)</code>)<br>。不过世界上还有一种叫作散列表（又叫哈希表，<code>Hash table</code>）的数据结构（有一个动态数组，+ 一个<code>hash</code>函数）。</p><p>但是有些时候我们只是需要知道某个元素是否在一个集合里面，其实并不需要存取这个元素本身，所以并不需要像<code>hashMap</code>或者<code>hashSet</code><br>那样存下所有数据。这个时候就要引入布隆过滤器了。</p><h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>布隆过滤器（Bloom Filter）是1970年由布隆提出的，它实质上是一个很长的二进制向量和一系列随机映射函数 (Hash函数)。<br><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/Snipaste_2024-06-08_15-36-52.png"><br>它用于判断这样的一个事情：某一个元素是否存在于一个集合里面。集合中的元素由哈希函数的映射规则，映射bitMap上的某一位；在bitMap上的每一位都是一个布尔类型的值，有两种状态0和1，0表示不存在于集合中，1表示存在于集合中，初始值都是0。这样相比较于使用数组、链表、哈希表等结构将集合中的元素本身存储下来，这样的做法，集合中的每一个元素只对应于bitMap的某几位，这样大大减少了存储的空间开销。</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>布隆过滤器的两个主要的操作，一个是布隆过滤器初始化，往过滤器中添加元素；另一个是使用布隆过滤器查询一个元素。往布隆过滤器中添加元素往往发生在布隆过滤器的初始化环节。主要的步骤如下：</p><ol><li>将要添加的元素进行哈希函数运算，得到该元素的哈希值；</li><li>将这个哈希值使用某种规则映射到bitMap数组上的某一位上（比如对数组的长度进行取模），如果这一位是0，则改为1；如果已经是1，则不用变；</li><li>一般布隆过滤器会有多个哈希函数，一个元素会被这多个哈希函数同时计算出多个哈希值，同时进行数组位置的映射，然后会将这多个映射位的状态值修改位1；<br><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/%E5%9B%BE%E7%89%871.png" alt="布隆过滤器添加元素"><br>如上图所示：bitMap一开始全部是0，data1经过3个哈希函数的计算分别得到3个哈希值，将这3个哈希值同时映射到数组上，将对应数组位置上的值改为1，如此就完成了一个元素添加到布隆过滤器中的过程。</li></ol><h3 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a>查询元素</h3><p>布隆过滤器的另一个操作就是查询某一个元素是否在布隆过滤器中。主要的过程和添加元素非常类似：</p><ol><li>将要查询的元素进行k个哈希函数的计算得到k个哈希值；</li><li>将这k个哈希值映射到数组上的k个位置；</li><li>检查这k个位置，如果有任何一个位置的值是0，则说明被查找的这个元素肯定不在布隆过滤器中；如果这k位全部都是1，说明被查找的元素可能在布隆过滤器中。</li></ol><p>由上面的过程我们可以知道，布隆过滤器查询一个元素，可以给我们返回两种结论，这两种结论的情况不同：</p><ol><li>当布隆过滤器返回元素不在集合中的时候，这个结论是靠谱的；</li><li>当布隆过滤器返回元素存在集合中的时候，这个结论是不靠谱的；</li></ol><p>为什么会有这样的结论呢？<br>这就要讨论到哈希函数的特性了，由于哈希冲突的存在，以及底层bitMap数组长度的限制，肯定会出现这样的情况：两个不同的元素，经过同一个哈希函数计算后得到的哈希值一样（出现了哈希冲突），或者两个不同的哈希值，经过映射后，被映射在了数组的同一个位置。无论是上面的哪种情况，都会出现这样的现象，不同元素经过元素映射在数组的同一个位置，当查找的时候就无法确定这一位的状态被改成了1，究竟是哪一个元素添加进来的时候改的，不可避免的就会出现误判。<br><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/%E5%9B%BE%E7%89%873.png" alt="布隆过滤器冲突"><br>如上所示，data1和data2经过hash3函数映射后映射在了数组的同一个位置，假如现在要判断data2这个元素是否存在于布隆过滤器中，当判断到hash3这个位置的时候发现这一位是1，但是这意味有可能是data1添加进来的时候改成的1，虽然在上面的例子中仍然由hash1和hash2函数映射的位置可以判断（这就是为什么要有多个哈希函数的原因），但是其他的位置上面出现的1，同样也是有可能是冲突的结果，而并不是这个元素本身添加进来修改的，由此还是会不可避免的出现误判的问题。</p><h3 id="误判率"><a href="#误判率" class="headerlink" title="误判率"></a>误判率</h3><p>由上面的内容可知，当我们要使用布隆过滤器判定元素存在于集合中的时候，是可能会存在误判的。误判的概率是多少呢？<br>参数：<br>m：布隆过滤器的bit长度。<br>n：插入过滤器的元素个数。<br>k：哈希函数的个数。</p><p>布隆过滤器的误判率计算公式：</p><p><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/%E5%9B%BE%E7%89%877.png" alt="布隆过滤器误判率计算公式"></p><p>误判率的计算公式的推导过程如下：</p><p><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/%E5%9B%BE%E7%89%8711.png" alt="布隆过滤器误判率公式推导过程"></p><p>在m和n一定,误判率尽量小的情况下，hash函数个数为：</p><p><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/%E5%9B%BE%E7%89%878.png" alt="布隆过滤器哈希函数个数与m和n的关系"></p><p>可以看到n和m一定的时候，可以算出k的最小值。</p><p>误判率和n确定的情况下，bit长度为：</p><p><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/%E5%9B%BE%E7%89%879.png" alt="布隆过滤器误判率和m与n之间的关系"></p><p>误判率和n成正相关，随者添加到布隆过滤器中的元素个数越来越多，误判率也会越来越大；和m成负相关，当数组的长度越大的时候，误判率会越小。</p><p>m,n,p,k之间的关系可以在这个网站上进行估计计算：<a href="https://hur.st/bloomfilter/">https://hur.st/bloomfilter/</a></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>布隆过滤器的最主要的优点就是极低的空间开销，集合中的一个元素，仅仅是映射成底层的几个比特位，这相比于其他的结构需要存储元素的所有信息而言，能节约非常多的内存开销，这意味这布隆过滤器的实现可以常驻在内存里面；时间复杂度也比较低，判断一个元素是否在布隆过滤器中的时间复杂度为O(<br>k)量级，k表示布隆过滤器内部的哈希函数的个数，一般这个值都不大。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>但是布隆过滤器的缺点也比较明显。</p><ol><li>首先就是它有一定的误判率，这个是由于哈希冲突所决定的，并且这个误判率会随着添加到布隆过滤器中的元素增加而升高；</li><li>另外一个比较明显的局限就是，布隆过滤器不支持删除元素操作。原因和上面的基本一样，如果先删除一个元素，将添加的过程逆向，就要将状态位1改为0，但是由于哈希冲突的存在，有可能会有别的元素同时也映射到这个位置，如果直接改为0，将意味着其他的元素可能会被误判。</li></ol><h2 id="布隆过滤器的应用"><a href="#布隆过滤器的应用" class="headerlink" title="布隆过滤器的应用"></a>布隆过滤器的应用</h2><ol><li>解决缓存穿透问题</li></ol><ul><li><p>什么是缓存穿透？</p><p> 在一个使用了缓存的系统中，如果大量的查询数据库中本就不存在的数据，那么这些查询就会绕过缓存，直接打到数据库上面。应为一般来讲，数据库中不存在的数据，也不会在缓存中存在，所以如果大量请求查询数据库中本就不存在的数据，那么缓存层也就无法缓解了。</p></li><li><p>其实这样的问题还是有解决方法的：</p><ul><li>做好接口的参数校验，对于一些恶意刷接口的请求进行拦截；</li><li>第一次查数据库的时候发现不存在，那么就将这个不存在的数据也缓存在缓存层里面，这样如果后续有查询重复查这个不存在的数据就能够在缓存层拦下来，从而不会对数据库造成太大的压力；</li><li>但是如果后面有源源不断的查询，查询之前没查过的，数据库中又不存在的数据的时候，上面的方法就无能为力了。</li></ul></li></ul><p>这个时候就要使用布隆过滤器来拦截了。通过在缓存层添加一个布隆过滤器，将数据库中明确存在的数据初始化到布隆过滤器中，对于后续的请求，查询缓存和数据库之前都先查找一下布隆过滤器，只要布隆过滤器返回不存在（上文提到，这个结论是靠谱的）那么这个元素一定不存在，可以直接返回空值，或者返回异常；如果布隆过滤器返回存在（这个结论不靠谱），我们就查询缓存，查询数据库，尽管布隆过滤器的这个结论是不靠谱的，可能会存在误报，即布隆过滤器返回了存在，但是实际上这个数据不存在，但是这个误报的概率足够小，就算让其请求进入到数据库查询，也不会对数据库造成什么压力。具体的流程如下：<br>  <img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/%E5%9B%BE%E7%89%875.png" alt="布隆过滤器解决缓存穿透流程"></p><ol start="2"><li>实现黑名单机制</li></ol><p>对于接口安全方面的考虑，一个重要的手段是在接口上加上Ip白名单校验，或者Ip黑名单校验。一般接口业务是To B的话可以考虑进行白名单校验，这样接口的安全性更高；但是如果接口的业务是To C的话，就要考虑使用黑名单了。而布隆过滤器就可以实现，将一些恶意的ip地址添加到布隆过滤器中，每次都对请求Ip进行校验，如果不在布隆过滤器中，就通过，否则就拦截请求。</p><ol start="3"><li>弱密码校验</li></ol><p>在注册业务上，一般我们要求用户设置密码不能过于简单，比如像:12345678这样的密码，太过于简单，非常容易让人猜到，这样的密码就是我们说的弱密码。在注册接口中，我们都会判断一下用户设置的密码是否是常见的弱密码，如果是弱密码，则要求用户重新输入。对于这样的场景，也可以使用布隆过滤器来实现，将一些常见的弱密码初始化到布隆过滤器中，用户提交注册请求的时候判断其密码是否在布隆过滤器中，如果在的话就说明可能是弱密码，要求用户重新输入。</p><ol start="4"><li>还有推荐系统，爬虫，甚至以太坊ETH的底层也使用了布隆过滤器来辅助实现一些功能…</li></ol><h2 id="布隆过滤器的实现"><a href="#布隆过滤器的实现" class="headerlink" title="布隆过滤器的实现"></a>布隆过滤器的实现</h2><p>布隆过滤器的思想诞生了将近50年，已经有非常多的商业实现，这些实现都是经过了非常多的业务场景的考验的，常见的实现有Guava工具包的实现，Ridsson框架的实现，Redis官方的实现……</p><h3 id="Guava工具包的实现"><a href="#Guava工具包的实现" class="headerlink" title="Guava工具包的实现"></a>Guava工具包的实现</h3><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>23.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>api</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>功能</strong></th><th><strong>参数</strong></th><th><strong>返回值</strong></th></tr></thead><tbody><tr><td>put</td><td>添加元素</td><td>put(T object)</td><td>boolean</td></tr><tr><td>mightContain</td><td>检查元素是否存在</td><td>mightContain(T object)</td><td>boolean</td></tr><tr><td>copy</td><td>根据此实例创建一个新的BloomFilte</td><td>copy()</td><td>BloomFilter</td></tr><tr><td>approximateElementCount</td><td>已添加到Bloom过滤器的元素的数量</td><td>approximateElementCount()</td><td>long</td></tr><tr><td>expectedFpp</td><td>返回元素存在的错误概率</td><td>expectedFpp()</td><td>double</td></tr><tr><td>isCompatible</td><td>确定给定的Bloom筛选器是否与此Bloom筛选器兼容</td><td>isCompatible(BloomFilterthat)</td><td>boolean</td></tr><tr><td>putAll</td><td>通过执行的逐位OR将此Bloom过滤器与另一个Bloom过滤器组合</td><td>putAll(BloomFilterthat)</td><td>void</td></tr></tbody></table><p>实例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GuavaBloomFilterTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 创建布隆过滤器对象</span></span><br><span class="line">    <span class="type">BloomFilter</span> <span class="variable">bloomFilter</span> <span class="operator">=</span> BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()),<span class="number">100000</span>,<span class="number">0.01</span>);</span><br><span class="line">    <span class="comment">// 向过滤器中添加元素</span></span><br><span class="line">    bloomFilter.put(<span class="string">&quot;element001&quot;</span>);</span><br><span class="line">    bloomFilter.put(<span class="string">&quot;element003&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断元素是否存在</span></span><br><span class="line">    System.out.println(bloomFilter.mightContain(<span class="string">&quot;element001&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(bloomFilter.mightContain(<span class="string">&quot;element002&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    <span class="comment">// 已添加到Bloom过滤器的元素的数量</span></span><br><span class="line">    System.out.println(bloomFilter.approximateElementCount());<span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 返回元素存在的错误概率</span></span><br><span class="line">    System.out.println(bloomFilter.expectedFpp());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redisson框架的实现"><a href="#Redisson框架的实现" class="headerlink" title="Redisson框架的实现"></a>Redisson框架的实现</h3><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>api</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>功能</strong></th><th><strong>参数</strong></th><th><strong>返回值</strong></th></tr></thead><tbody><tr><td>add</td><td>添加元素</td><td>add(T object)</td><td>boolean</td></tr><tr><td>contains</td><td>检查元素是否存在</td><td>contains(T object)</td><td>boolean</td></tr><tr><td>count</td><td>已添加到Bloom过滤器的元素的数量</td><td>count()</td><td>long</td></tr><tr><td>getExpectedInsertions</td><td>返回的预期插入元素的个数</td><td>getExpectedInsertions()</td><td>long</td></tr><tr><td>getFalseProbability</td><td>返回元素存在的错误概率</td><td>getFalseProbability()</td><td>double</td></tr><tr><td>getHashIterations</td><td>返回每个元素使用的哈希迭代次数</td><td>getHashIterations()</td><td>int</td></tr><tr><td>getSize</td><td>返回此实例所需Redis内存的位数</td><td>getSize()</td><td>long</td></tr><tr><td>tryInit</td><td>初始化Bloom筛选器参数</td><td>tryInit(long expectedInsertions, double falseProbability)</td><td>boolean</td></tr><tr><td>delete</td><td>删除对象</td><td>delete()</td><td>boolean</td></tr></tbody></table><p>实例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RedissonBloomFilterTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">&quot;redis://&quot;</span> + <span class="string">&quot;localhost&quot;</span> + <span class="string">&quot;:&quot;</span> + <span class="number">6379</span>);</span><br><span class="line">    config.useSingleServer().setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取客户端</span></span><br><span class="line">    <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">    RBloomFilter&lt;String&gt; bloomFilter = redissonClient.getBloomFilter(<span class="string">&quot;REDISSON_BLOOM_FILTER_20246&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化布隆过滤器：预期插入量为100000000L,预期错误概率为1%</span></span><br><span class="line">    bloomFilter.tryInit(<span class="number">100000</span>, <span class="number">0.01</span>);</span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    bloomFilter.add(<span class="string">&quot;element001&quot;</span>);</span><br><span class="line">    bloomFilter.add(<span class="string">&quot;element003&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断下面元素是否在布隆过滤器中</span></span><br><span class="line">    System.out.println(bloomFilter.contains(<span class="string">&quot;element002&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(bloomFilter.contains(<span class="string">&quot;element001&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已添加到Bloom过滤器的元素的数量</span></span><br><span class="line">    System.out.println(bloomFilter.count());<span class="comment">//2</span></span><br><span class="line">    <span class="comment">// 预期插入元素的个数</span></span><br><span class="line">    System.out.println(bloomFilter.getExpectedInsertions());<span class="comment">//1000000</span></span><br><span class="line">    <span class="comment">// 元素存在的错误概率</span></span><br><span class="line">    System.out.println(bloomFilter.getFalseProbability());<span class="comment">//0.01</span></span><br><span class="line">    <span class="comment">// 每个元素使用的哈希迭代次数</span></span><br><span class="line">    System.out.println(bloomFilter.getHashIterations());</span><br><span class="line">    <span class="comment">// 实例所需Redis内存的位数</span></span><br><span class="line">    System.out.println(bloomFilter.getSize());</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">delete</span> <span class="operator">=</span> bloomFilter.delete();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis官方插件的实现"><a href="#Redis官方插件的实现" class="headerlink" title="Redis官方插件的实现"></a>Redis官方插件的实现</h3><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>api</p><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th><th><strong>参数</strong></th></tr></thead><tbody><tr><td>BF.RESERVE</td><td>创建一个大小为capacity，错误率为error_rate的空的Bloom</td><td>BF.RESERVE {key} {error_rate} {capacity} [EXPANSION {expansion}] [NONSCALING]</td></tr><tr><td>BF.ADD</td><td>向key指定的Bloom中添加一个元素itom</td><td>BF.ADD {key} {item}</td></tr><tr><td>BF.MADD</td><td>向key指定的Bloom中添加多个元案</td><td>BF.MADD {key} {item …}</td></tr><tr><td>BF.INSERT</td><td>向key指定的Bloom中添加多个元素，添加时可以指定大小和错误率，且可以控制在Bloom不存在的时候是否自动创建</td><td>BF.INSERT {key} [CAPACITY {cap}] [ERROR {error}] [EXPANSION {expansion}] [NOCREATE] [NONSCALING] ITEMS {item …}</td></tr><tr><td>BF.EXISTS</td><td>检查一个元秦是否可能存在于key指定的Bloom中</td><td>BF.EXISTS {key} {item}</td></tr><tr><td>BF.MEXISTS</td><td>同时检查多个元素是否可能存在于key指定的Bloom中</td><td>BF.MEXISTS {key} {item …}</td></tr><tr><td>BF.SCANDUMP</td><td>对Bloom进行增量持久化操作</td><td>BF.SCANDUMP {key} {iter}</td></tr><tr><td>BF.LOADCHUNK</td><td>加载SCANDUMP持久化的Bloom数据</td><td>BF.LOADCHUNK {key} {iter} {data}</td></tr><tr><td>BF.INFO</td><td>查询key指定的Bloom的信息</td><td>BF.INFO {key}</td></tr><tr><td>BF.DEBUG</td><td>查看BloomFilter的内部详细信息(如每层的元素个数，错误率等)</td><td>BF.DEBUG (key}</td></tr></tbody></table><p>实例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">JedisBloomFilterTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    <span class="type">BloomFilterCommands</span> <span class="variable">bloomFilterCommands</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPooled</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">// 构建布隆过滤器参数</span></span><br><span class="line">    <span class="type">BFReserveParams</span> <span class="variable">bfReserveParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BFReserveParams</span>();</span><br><span class="line">    bfReserveParams.expansion(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个过滤器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> bloomFilterCommands.bfReserve(<span class="string">&quot;JEDIS_BLOOM_FILTER_20246&quot;</span>, <span class="number">10000</span>, <span class="keyword">new</span> <span class="title class_">Long</span>(<span class="string">&quot;0.01&quot;</span>), bfReserveParams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向过滤器中添加元素</span></span><br><span class="line">    bloomFilterCommands.bfAdd(<span class="string">&quot;JEDIS_BLOOM_FILTER_20246&quot;</span>, <span class="string">&quot;element001&quot;</span>);</span><br><span class="line">    bloomFilterCommands.bfAdd(<span class="string">&quot;JEDIS_BLOOM_FILTER_20246&quot;</span>, <span class="string">&quot;element003&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断元素是否存在</span></span><br><span class="line">    System.out.println(bloomFilterCommands.bfExists(<span class="string">&quot;JEDIS_BLOOM_FILTER_20246&quot;</span>, <span class="string">&quot;element001&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(bloomFilterCommands.bfExists(<span class="string">&quot;JEDIS_BLOOM_FILTER_20246&quot;</span>, <span class="string">&quot;element002&quot;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自己手写一个简单版的布隆过滤器"><a href="#自己手写一个简单版的布隆过滤器" class="headerlink" title="自己手写一个简单版的布隆过滤器"></a>自己手写一个简单版的布隆过滤器</h3><p>考虑的点：</p><ol><li><p>选什么哈希函数？选计算性能高的，尽可能离散的。比如MurmurHash(Guava<br>实现的BloomFilter使用的是这个 <a href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp)%E3%80%81KetamaHash%E7%AD%89%E3%80%82">https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp)、KetamaHash等。</a></p></li><li><p>到底进行几次hash映射k的值怎么选？二进制向量的长度设置为多少比较好？（有公式计算的）</p></li></ol><h2 id="布隆过滤器的局限和发展"><a href="#布隆过滤器的局限和发展" class="headerlink" title="布隆过滤器的局限和发展"></a>布隆过滤器的局限和发展</h2><p>其实布隆过滤器的局限性还是蛮大的，不支持删除就是其中比较突出的一个。</p><p>布隆过滤器诞生至今50多年了，产生了很多变种和改进型。</p><p>改进的方向：</p><ol><li>更加高效的哈希函数（甚至完美哈希函数）</li><li>更加极致的空间利用率</li><li>支持删除</li></ol><p>布隆过滤器的优化拓展：<br><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/%E5%9B%BE%E7%89%8712.png" alt="布隆过滤器的优化拓展"></p><h3 id="计数布隆过滤器"><a href="#计数布隆过滤器" class="headerlink" title="计数布隆过滤器"></a>计数布隆过滤器</h3><p>原理：</p><ol><li><p>给定长度为 N*Mbits 的哈希空间。M 是用来存计数的位大小，比如当M取 4时，最大计数为 15，此时会溢出的概率已经足够小。</p></li><li><p>插入：选取 d 个哈希函数，每个哈希函数将给定的元素映射到[0，N-1]的一个位置上，并将该位对应的值+1。如果值大于 15，则取 15。</p></li><li><p>删除：选取 d 个哈希函数，每个哈希函数将给定的元素映射到[0，N-1]的一个位置上，并将该位对应的值-1。如果值小于 0，则取 0。</p></li><li><p>判断存在：和经典布隆过滤器相同。</p></li></ol><p><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/%E5%9B%BE%E7%89%876.png" alt="计数布隆过滤器"></p><p>代价呢？</p><ol><li><p>使用了更多的空间，空间需求是经典布隆过滤器的M倍(m取决于底层存储的数组使用多少位来存储计数)</p></li><li><p>还是存在溢出的可能，一旦溢出，还是又造成误判的可能，或者一旦计数溢出了，误判的概率会变大。</p></li><li><p>删除一个元素之前，这个元素必须明确知道已经加入了过滤器中，不能删除未加入的元素。</p></li></ol><h3 id="布谷鸟过滤器"><a href="#布谷鸟过滤器" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h3><p>具有更好的空间利用率和更低的误判率，并且支持删除。但是复杂度太高。<br>参考：<br><a href="https://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf">https://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf</a></p><p><a href="http://www.linvon.cn/posts/cuckoo/">http://www.linvon.cn/posts/cuckoo/</a></p><h3 id="可扩展的布隆过滤器"><a href="#可扩展的布隆过滤器" class="headerlink" title="可扩展的布隆过滤器"></a>可扩展的布隆过滤器</h3><p>因为大多数的时候对于要添加的元素个数是未知的，传统的布隆过滤器随者添加的元素越来越多，误判率也会越来越大，最后不得不重建。<br>但是Scalable Bloom Filter可以动态扩容。</p><p>注：Redis官方实现的布隆过滤器底层就是使用的可扩容的布隆过滤器</p><p>Redis官网对可扩展的布隆过滤器的介绍：<br><a href="https://redis.io/blog/bloom-filter/">https://redis.io/blog/bloom-filter/</a></p><p><img src="https://raw.githubusercontent.com/XiaobinL/BlogSrc/main/img/BloomFilter/Snipaste_2024-06-09_12-07-10.png" alt="Redis官网对可扩展的布隆过滤器的介绍"></p><h3 id="其他拓展的布隆过滤器"><a href="#其他拓展的布隆过滤器" class="headerlink" title="其他拓展的布隆过滤器"></a>其他拓展的布隆过滤器</h3><p>Ribbon Filter和Xor Filter:</p><p>阿里团队曾经将这个过滤器引入自己存储框架里面，并进行了测试，具体的详情参考：<br><a href="https://developer.aliyun.com/article/980796">https://developer.aliyun.com/article/980796</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 布隆过滤器 </tag>
            
            <tag> Redisson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理的原理</title>
      <link href="/2023/09/10/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2023/09/10/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>更新中……</p>]]></content>
      
      
      <categories>
          
          <category> 开发进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK动态代理 </tag>
            
            <tag> CGlib动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射相关</title>
      <link href="/2023/08/29/%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/08/29/%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h1><p>JAVA反射技术是在<strong>运行状态中：</strong></p><ol><li>对于任意一个类，都能够知道这个类的所有属性和方法（包括私有）</li><li>对于任意一个对象，都能够调用它的任意一个方法，访问任意一个属性。</li></ol><p>这种动态获取类型信息，以及动态调用对象方法的功能，被称为Java语言的反射机制。</p><p><strong>总之，反射是提供获取运行时类信息的一种技术，或者更通俗一点反射技术就是操作一个类的<code>Class对象</code>。</strong></p><p>反射可以在程序运行的过程中，动态地加载一个类，并且能拿到一个类的全部详细信息，从而可以操作该类的属性和方法。反射技术源于<code>Class对象</code>，其本质就是通过一个类的<code>Class对象</code>来获得该类的信息，并操作该类的属性和方法。反射技术应用的起点就是获取某个类的<code>Class对象</code>。那么什么是<code>Class对象</code>？</p><h2 id="关于Class对象"><a href="#关于Class对象" class="headerlink" title="关于Class对象"></a>关于Class对象</h2><p>什么是<code>Class对象</code>？用来描述一个类的对象。<code>Class对象</code>作为一个对象，其也是由类创建出来的，这个类就是<code>java.lang</code>包下的<code>Class</code>类，<code>Class类</code>没有公共构造函数，<code>Class对象</code>是由Java虚拟机在加载类时自动构建的，通过调用类加载器中的<code>defineClass</code>方法来构建。类加载的过程可以分为三步：加载，链接，初始化。其中的第一步：加载，完成的功能就是将一个类的字节码文件读到方法区，并在堆区生成相应的<code>Class对象</code>。</p><p><code>Class对象</code>里面记录着每个类的运行时数据结构，基本包括类的所有信息，包括属性，方法，注解等等。基本<code>Java</code>里面的所有类型都有<code>Class对象</code>：</p><ol><li>普通的<code>class类</code>（外部类，内部类）</li><li>接口 <code>interface</code></li><li><code>[]</code> 数组</li><li>枚举 <code>enum</code></li><li>注解 <code>@interface</code></li><li>基本数据类型 <code>(boolean,byte,char,int,float,double,long)</code></li><li><code>void</code></li></ol><p>注意：如果两数组的维数以及元素的数据类型相同，那么他们的<code>Class对象</code>是同一个。</p><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>一般上获取<code>Class对象</code>有4种方式</p><ol><li><p><code>Class.forName(“全限定类名”)</code>:此方法是<code>Class类</code>的静态成员方法，此方法会触发类加载阶段的最后一个阶段：类初始化阶段（执行<code>Clinit()</code>方法）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>对象名.getClass()</code>:此方法是<code>Object类</code>的方法，因此所有的类中都会继承该方法，但是需要用对象来调用。此方法会触发类加载阶段的最后一个阶段：类初始化阶段（执行<code>Clinit()</code>方法）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> <span class="string">&quot;ZS&quot;</span>.getClass();</span><br></pre></td></tr></table></figure></li><li><p><code>类名/接口(类字面常量).class</code>:此方法并不会触发类加载阶段的最后一个阶段：类初始化阶段（不会执行<code>Clinit()</code>方法）意味着该方法获得<code>Class对象</code>时不会自动初始化该<code>Class对象</code>，而是延迟到静态成员访问或静态方法调用的时候才初始化。（如果一个成员变量同时被<code>static</code>和<code>final</code>修饰，被称为“编译时常量”，在编译期就已经将其放进常量池，访问这个常量，并不会触发类加载，但是如果只是被他们的其中的一个修饰，则没有这个效果）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">personClass</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure></li><li><p><code>(类加载器)ClassLoader</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Person.class.getClassLoader();</span><br><span class="line">Class&lt;?&gt; pClass = classLoader.loadClass(<span class="string">&quot;com.xiaobin.Person&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>因为类加载只有一次，因此同一个类的<code>Class对象</code>也只有一个，通过上面不同方法获取到的同一个类的<code>Class对象</code>是同一个对象。</p><h1 id="反射的相关用法"><a href="#反射的相关用法" class="headerlink" title="反射的相关用法"></a>反射的相关用法</h1><p><code>Class对象</code>是反射的入口，反射的几乎所有用法都是在使用<code>Class类</code>里面的相关方法，完成一些功能。对于一个类我们获取了其相应的<code>Class对象</code>，那么我们可以获取到它的所有信息（包括私有的）意味着我们可以做很多事情。</p><h2 id="属性相关的操作"><a href="#属性相关的操作" class="headerlink" title="属性相关的操作"></a>属性相关的操作</h2><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>通过<code>Class对象</code>可以获取一个类的所有属性，相关方法如下：</p><ol><li><p>获取子类以及父类中的一个对应public权限的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">value</span> <span class="operator">=</span> aClass1.getField(属性名);<span class="comment">//获取相应名字的public属性，包含父类的public属性</span></span><br></pre></td></tr></table></figure></li><li><p>获取子类中声明过的所有属性（包括private的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">value1</span> <span class="operator">=</span> aClass1.getDeclaredField(属性名);<span class="comment">//获取相应名字的属性(可以是private的)，但不包含父类的任何属性</span></span><br></pre></td></tr></table></figure></li><li><p>获取子类和父类中的所有public属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = aClass1.getFields();<span class="comment">//获取所有的public属性，包括父类中的所有public属性</span></span><br></pre></td></tr></table></figure></li><li><p>获取本类中声明过的所有属性（包括private的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] declaredFields = aClass1.getDeclaredFields();<span class="comment">//获取本类中所有的属性（含private的），但是不包含父类的任何属性</span></span><br></pre></td></tr></table></figure></li></ol><p>以上的方法的特点：</p><ol><li><p>方法名后面有<code>s</code>的就是获取所有的属性，返回的是属性的数组（<code>File</code>类型数组，里面的每个元素就是一个属性）</p></li><li><p>方法名有<code>Declared</code>（宣布的，声明的）的表示只能获取到本类声明的属性（public是声明的、private也是声明的，所以能获取到本类中的所有属性，包括private）</p></li><li><p>通过一个子类的<code>Class对象</code>是没有办法直接获取到父类中的private属性的<code>Field</code>，<code>Method</code>或<code>Constructor</code>类的。要想获取到父类中的private属性，要先获取到父类的<code>Class对象</code>,如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; superclass = aClass1.getSuperclass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">value</span> <span class="operator">=</span> superclass.getDeclaredField(父类私有属性名);</span><br></pre></td></tr></table></figure><blockquote><p>​但是子类会隐式继承父类的private属性的成员，而且在通过以上的方法获得父类中private权限的Field、Method、Constructor之后，通过传进一个子类对象，就可以访问到子类中通过隐式继承得到的父类的private成员，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo7</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"><span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">666</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">Son</span>&gt; sonClazz = son.getClass();</span><br><span class="line"><span class="comment">// 获取父类类型Class对象</span></span><br><span class="line">Class&lt;?&gt; fatherClazz = sonClazz.getSuperclass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">numFiled</span> <span class="operator">=</span> fatherClazz.getDeclaredField(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"><span class="comment">// 破解访问权限</span></span><br><span class="line">numFiled.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 输出子类对象中a的结果(注意这里虽然是通过父类的Class对象获取到的Field类对象，但是是将子类的对象传进去的，表示获取子类对象中的这个成员)</span></span><br><span class="line">System.out.println(numFiled.get(son));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类对象调用父类私有成员方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">sayHiMethod</span> <span class="operator">=</span> fatherClazz.getDeclaredMethod(<span class="string">&quot;sayHi&quot;</span>);</span><br><span class="line">sayHiMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//这里也是一样的，虽然是通过父类的Class对象获取到的Method类对象，但是调用的时候传进取得对象是子类对象，表示调用的是子类的这个方法。</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> sayHiMethod.invoke(son);</span><br><span class="line"><span class="comment">// 无返回值,o是null</span></span><br><span class="line">System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你好啊,朋友!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的程序输出的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">666</span></span><br><span class="line">你好啊,朋友!</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>返回的是一个<code>Field</code>类的对象，这个<code>Field</code>类对象里面封装了对应类的属性信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><p> 比如<code>String类</code>底层存储字符串的是一个<code>char[]</code>,它的定义如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String类的Class对象</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">strClass</span> <span class="operator">=</span> Class.forName(“java.lang.String”);</span><br><span class="line">    <span class="comment">//获取成员变量</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> strClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="comment">//获取该成员变量的名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName(); --&gt; <span class="string">&quot;value&quot;</span></span><br><span class="line">    <span class="comment">//获取该成员变量的类型</span></span><br><span class="line">    Class&lt;?&gt; type = field.getType(); --&gt; class [C  表示为一个<span class="type">char</span>类型的数组</span><br><span class="line">    <span class="comment">//获取该成员的modifiers,返回的是一个int型的值，不同的表示的内容不一样，通过Modifier.isXXX()方法可以获得该成员变量的修饰情况</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> field.getModifiers();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">aFinal</span> <span class="operator">=</span> Modifier.isFinal(modifiers);  --&gt; <span class="literal">true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">aPublic</span> <span class="operator">=</span> Modifier.isPublic(modifiers); --&gt; <span class="literal">false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">aPrivate</span> <span class="operator">=</span> Modifier.isPrivate(modifiers); --&gt; <span class="literal">true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">aStatic</span> <span class="operator">=</span> Modifier.isStatic(modifiers); --&gt; <span class="literal">false</span>   </span><br></pre></td></tr></table></figure></li></ol><h3 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h3><p>在获取到相应的属性之后，我们可以给相应的属性赋值。</p><p>在这之前要先解决运行时访问检查的事情。</p><blockquote><p>当Field、Method或Constructor（三者都是反射对象）分别用于设置字段（<code>set(Object obj, Object value)</code>）或获取字段（<code>get(Object obj)</code>）、调用方法（<code>invoke(Object obj, Object... args)</code>）或创建和初始化类的新实例（<code>newInstance(Object... initargs)</code>）时，将执行运行时访问检查。主要是检查相关的操作是否有权限等等。</p></blockquote><p><code>AccessibleObject类</code>，是<code>Field</code>、<code>Method</code>、<code>Constructor</code>的公共父类。通过继承该类，<code>Field</code>、<code>Method</code>、<code>Constructor</code>获得了一个方法<code>setAccessible(boolean flag)</code>方法，可以设置对一个操作是否进行访问检查。</p><ul><li><code>accessible</code>默认为false，表示会进行运行时访问检查。注意：就算是public权限的也会进行访问检查，只是访问检查后对其操作没有影响；而protected和private权限的进行访问权限检查之后可能会由于权限不够而报异常。</li><li>可以通过<code>setAccessible(true)</code>取消运行访问检查，这样就可以任意访问任何权限的内容。同时因为运行访问检查要耗费一定的时间，因此跳过运行访问检查也可以提升反射的运行速度。</li></ul><p>在解决完运行时访问检查之后，我们可以对任意的一个属性进行赋值操作：</p><ol><li><p>获取相应的属性的值：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field.get(对象a名)；</span><br></pre></td></tr></table></figure><p> 表示获取对象a的相应的属性的值</p></li><li><p>设置属性的值：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field.set(对象a名，想设置的值);</span><br></pre></td></tr></table></figure><p> 表示将对象a的相应属性设置为对应的值。</p></li></ol><h2 id="获取构造器、创建对象实例"><a href="#获取构造器、创建对象实例" class="headerlink" title="获取构造器、创建对象实例"></a>获取构造器、创建对象实例</h2><p>通过一个<code>Class对象</code>，我么可以获取到相应类的构造器。</p><p>相应的方法如下：</p><ol><li><p>获得一个public权限的构造器（因为构造器不能被继承，所以这里没有父类的构造器的事情）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;Son&gt; constructor = sonClass.getConstructor(Integer.class , String.class);<span class="comment">//根据传入的参数类型返回一个对应的public权限的构造器</span></span><br></pre></td></tr></table></figure></li><li><p>获得本类中的所有构造器，包括private修饰的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;Son&gt; constructor = sonClass.getDeclaredConstructor(Integer.class , String.class);<span class="comment">//根据传入的参数类型返回一个对应的构造器(任何权限都可以返回)</span></span><br></pre></td></tr></table></figure></li><li><p>获得所有public修饰的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors = sonClass.getConstructors();<span class="comment">//获取所有的public的构造器</span></span><br></pre></td></tr></table></figure></li><li><p>获得所有的构造器，包括private修饰的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] declaredConstructors = sonClass.getDeclaredConstructors();<span class="comment">//获取所有的构造器</span></span><br></pre></td></tr></table></figure></li></ol><p>获取到构造器之后就可以在程序运行的时候动态创建一个对象实例。</p><p>通过：<code>Son son1 = constructor.newInstance(1, 2, &quot;123&quot;);</code>通过传进来相应的值创建一个实例。</p><p>另外还可以通过<code>Class对象.newInstance()</code>方法来创建一个实例，但是这样只能通过无参构造器来创建实例。</p><h2 id="获取并调用方法"><a href="#获取并调用方法" class="headerlink" title="获取并调用方法"></a>获取并调用方法</h2><p>通过<code>Class对象</code>获取类里面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> sonClass.getMethod(方法名 , 形参列表Calss);<span class="comment">//获取相应的public方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> sonClass.getDeclaredMethod(方法名,形参列表Class);<span class="comment">//获取相应的方法（含private）</span></span><br><span class="line">Method[] methods = sonClass.getMethods();<span class="comment">//获取所有的public方法</span></span><br><span class="line">Method[] declaredMethods = sonClass.getDeclaredMethods();<span class="comment">//获取所有的方法（含private）</span></span><br></pre></td></tr></table></figure><p>调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.invok(对象名，实参列表)；<span class="comment">//调用相应对象的方法，并传入实参，该实参列表是可变参数，因此可以使用Object[]进行传参</span></span><br></pre></td></tr></table></figure><p>另外通过反射进行的方法调用仍然遵循多态，运行时总是呈现实际对象的结果</p><h2 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h2><p>通过反射可以获取一个类，类的方法，属性的注解，并拿到里面的相应的信息，这是许多框架的通用做法。</p><ol><li><p>判断一个类上是否有相应的注解标记：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">annotationPresent</span> <span class="operator">=</span> sonClass.isAnnotationPresent(注解名.class);</span><br></pre></td></tr></table></figure></li><li><p>获得类上的注解：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注解名 annotation = (注解名) sonClass.getAnnotation(注解名.class);</span><br></pre></td></tr></table></figure></li><li><p>拿到注解后，可以进一步拿到注解里面的信息。比如一个注解里面有一个<code>value</code>属性，则可以通过以下方法来获得：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> annotation.value();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池的创建与使用</title>
      <link href="/2023/08/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/08/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>当我们要并发处理一些任务的时候，需要使用到多线程技术。一般是通过<code>new Thread()</code>来新建一个线程实现并发执行，但是这样做其实有不少的弊端：主要是因为频繁进行线程的创建和销毁非常耗费性能和资源，一个线程大费周章的创建后，可能只是简单执行一些任务后就马上大费周章的销毁，做不到复用。同时如果短时间内大量的任务到来，线程大量的创建，此时系统会出现性能的瓶颈，甚至占用过多资源而阻塞系统或<code>oom</code>等状况，从而降低系统的稳定性。因此使用线程池是更常用的方法，使用线程池的好处能够很好的解决上面面临的问题：降低系统资源消耗、提高系统响应速度、方便线程的管理。</p><p>一般来说线程池的创建和使用有三种方式：一种是使用<code>juc</code>包下的<code>Executors </code>工厂类，另一种是直接new一个<code>ThreadPoolExecutor</code>实例，其实<code>juc</code>包下的<code>Executors </code>工厂类底层也是new的<code>ThreadPoolExecutor</code>实例来实现的。还有一种是使用<code>Spring</code>封装的线程池，底层也是对<code>ThreadPoolExecutor</code>的封装。</p><h1 id="Java线程池的核心参数"><a href="#Java线程池的核心参数" class="headerlink" title="Java线程池的核心参数"></a>Java线程池的核心参数</h1><p>线程池在创建的时候需要指定7个参数，分别是：</p><ol><li><p><code>corePoolSize</code>：核心线程数，线程池中长期存活的线程数量，可以传一个<code>Integer</code>类型的值。</p></li><li><p><code>maximumPoolSize</code>：最大线程数，线程池允许创建的最大线程数量。当线程池中的长期存活的线程都在忙的时候，可以再临时创建线程来执行这个任务，但是新创建的临时线程也是有上限的，<code>线程池中的长期线程+临时的线程&lt;=maximumPoolSize</code>，可以传一个<code>Integer</code>类型的值，且不能小于<code>corePoolSize</code>。</p></li><li><p><code>keepAliveTime</code>：空闲线程存活时间。当临时创建的线程执行完任务之后，空闲了<code>keepAliveTime</code>的时间就会被回收释放，传入的是一个<code>Long</code>类型的值。</p></li><li><p><code>TimeUnit</code>：时间单位，表示上面的<code>keepAliveTime</code>的时间单位。传入的是一个枚举类型。通常取值：</p><ul><li><code>TimeUnit.NANOSECONDS;</code>纳秒</li><li><code>TimeUnit.MICROSECONDS;</code>微秒</li><li><code>TimeUnit.MILLISECONDS;</code>毫秒</li><li><code>TimeUnit.SECONDS;</code>秒</li><li><code>TimeUnit.MINUTES;</code>分</li><li><code>TimeUnit.HOURS;</code>时</li><li><code>TimeUnit.DAYS;</code>天</li></ul></li><li><p><code>BlockingQueue</code>：线程池任务队列。这是一个阻塞队列，用于存储等待执行的任务。当线程池中的线程都在忙碌时，新提交的任务会被放入队列中等待执行。可传的值可以是不同类型的阻塞队列：</p><ul><li><code>new ArrayBlockingQueue&lt;Runnable/Callable&gt;():</code>  <code>ArrayBlockingQueue</code>,一个由数组结构组成的<strong>有界阻塞队列</strong>。</li><li><code>new LinkedBlockingQueue&lt;Runnable/Callable&gt;(): ``LinkedBlockingQueue</code>,一个由链表结构组成的<strong>有界阻塞队列</strong>。</li><li><code>new SynchronousQueue&lt;Runnable/Callable&gt;():</code> <code>SynchronousQueue</code>,一个不存储元素的阻塞队列，即直接提交给线程不保持它们。</li><li><code>new PriorityBlockingQueue&lt;Runnable/Callable&gt;():</code> <code>PriorityBlockingQueue</code>,一个支持优先级排序的<strong>无界阻塞队列</strong>。</li><li><code>new DelayQueue&lt;Runnable/Callable&gt;():</code> <code>DelayQueue</code>：一个使用优先级队列实现的<strong>无界阻塞队列</strong>，只有在延迟期满时才能从中提取元素。</li><li><code>new LinkedTransferQueue&lt;Runnable/Callable&gt;():</code> <code>LinkedTransferQueue</code>,一个由链表结构组成的<strong>无界阻塞队列</strong>。与<code>SynchronousQueue</code>类似，还含有非阻塞方法。</li><li><code>new LinkedBlockingDeque&lt;Runnable/Callable&gt;():</code> <code>LinkedBlockingDeque</code>,一个由链表结构组成的<strong>双向阻塞队列</strong>。</li></ul><p>比较常用的是<code>LinkedBlockingQueue</code>，线程池的排队策略和<code>BlockingQueue</code> 息息相关。</p></li><li><p><code>ThreadFactory</code>：创建线程的工厂。用于创建新的线程。通常情况下，可以使用 <code>Executors.defaultThreadFactory()</code>来使用默认的线程工厂，也可以自定义线程工厂以满足特定需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义线程工厂类</span></span><br><span class="line"><span class="comment">//实现ThreadFactory接口，并重写里面的newThread方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并返回自定义的线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程名称</span></span><br><span class="line">        thread.setName(<span class="string">&quot;Thread-&quot;</span> + r.hashCode());</span><br><span class="line">        <span class="comment">// 设置线程优先级（最大值：10）</span></span><br><span class="line">       thread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        <span class="comment">// 设置线程的守护状态</span></span><br><span class="line">        thread.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回新线程</span></span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用lambda表达式完成传参</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">3000l</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">200</span>), r -&gt; &#123;</span><br><span class="line">         <span class="comment">// 创建并返回自定义的线程对象</span></span><br><span class="line">         <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">         <span class="comment">// 设置线程名称</span></span><br><span class="line">         thread.setName(<span class="string">&quot;Thread-&quot;</span> + r.hashCode());</span><br><span class="line">         <span class="comment">// 设置线程优先级（最大值：10）</span></span><br><span class="line">         thread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">         <span class="comment">// 设置线程的守护状态</span></span><br><span class="line">         thread.setDaemon(<span class="literal">false</span>);</span><br><span class="line">         <span class="comment">// 返回新线程</span></span><br><span class="line">         <span class="keyword">return</span> thread;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>RejectedExecutionHandler</code>：拒绝策略。当线程池已经达到最大线程数并且任务队列也已满时，新提交的任务会被拒绝执行。这个参数用于定义在出现这种情况时应采取的策略。可传的值通常是预定义的策略，如： </p><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：拒绝并抛出异常。(默认为这种)</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：使用当前调用的线程来执行此任务。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：抛弃队列头部（最旧）的一个任务，并执行当前任务。</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：忽略并抛弃当前任务。</li></ul></li></ol><h1 id="Java线程池的使用"><a href="#Java线程池的使用" class="headerlink" title="Java线程池的使用"></a>Java线程池的使用</h1><p>在了解了线程池的7个参数之后我么就可以创建一个线程池，使用它了。下面分别是上面提到的3中创建使用的方式。</p><h2 id="juc包下的Executors-工厂类"><a href="#juc包下的Executors-工厂类" class="headerlink" title="juc包下的Executors 工厂类"></a><code>juc</code>包下的<code>Executors </code>工厂类</h2><p>使用工具类<code>Executors</code>生产一个线程池，最常用的线程池（三个静态方法）如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特点:</span></span><br><span class="line"><span class="comment">// 1.维护了一个可自动扩容的线程容器，每当需要执行一个新任务时，有活跃的线程就使用该线程，否则就新建一条线程。</span></span><br><span class="line"><span class="comment">// 2.线程池的最大线程数为Integer.MAX_VALUE，基本上不受限制。</span></span><br><span class="line"><span class="comment">// 3.使用完毕后的线程会回归线程池，如果这个线程在60秒之后依旧空闲，那么就会被移除</span></span><br><span class="line"><span class="comment">// 4.线程池初始线程个数为0</span></span><br><span class="line"><span class="comment">// 适用于线程生命周期短且频繁创建的场景</span></span><br><span class="line">ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特点:</span></span><br><span class="line"><span class="comment">// 1.创建一个固定线程数量的线程池，在整个线程池的生命周期中，线程池中的数量不会变化</span></span><br><span class="line"><span class="comment">// 2.维护一个无界队列（暂存已提交的来不及执行的任务）按照任务的提交顺序，将任务执行完毕  </span></span><br><span class="line"><span class="comment">// 这种类型的线程池适用于执行长时任务或需要限制并发数量的场景。</span></span><br><span class="line">ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特点:</span></span><br><span class="line"><span class="comment">// 1.线程数量固定为1个，在整个线程池的生命周期中，线程池中的数量不会变化</span></span><br><span class="line"><span class="comment">// 2.维护了一个无界队列（暂存已提交的来不及执行的任务）按照任务的提交顺序，将任务执行完毕  </span></span><br><span class="line"><span class="comment">// 这种类型的线程池适用于需要保证任务顺序执行，不需要同时执行的场景</span></span><br><span class="line">ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span></span><br></pre></td></tr></table></figure><br>其中无界队列指的是一个不确定长度的可自由扩容的队列，遵循”先进先出”的特点，理论上可以容量无限的任务。<br>使用以上方法就可以得到一个具有相应特点的线程池对象，具体情况使用哪个线程池要具体分析。<br>上面通过<code>Executors</code>创建的线程池，返回的是一个实现了<code>ExecutorService</code>接口的线程池，我们通常使用这个接口来承接返回的线程池，我们可以通过这个接口中的一系列方法来操作管理线程池，比如提交任务，关闭线程池等。<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交一个Runnable类型的任务(实现了Runnable接口，并重写了run方法的任务)，任务的执行没有返回值，可以不接返回值</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交一个Callable类型的任务(实现了Callable接口，并重写而来call方法的任务)，任务的执行有返回值，返回值封装在一个Future&lt;T&gt;类型的值中，通过其中的get()方法获得</span></span><br><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行完任务列表中所有已提交的任务，关闭线程池，不再接受新任务。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 立刻停止所有正在执行的活动任务，也不再处理任务列表中等待的任务，并直接返回等待执行的任务列表。</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="new-ThreadPoolExecutor实例"><a href="#new-ThreadPoolExecutor实例" class="headerlink" title="new  ThreadPoolExecutor实例"></a>new  <code>ThreadPoolExecutor</code>实例</h2><p>上面我们使用了工具类<code>java.util.concurrent.Executors</code>的静态方法来获取一个线程池对象，但从实际的开发中讲，这种做法是错误的。比如阿里巴巴<code>Java</code>开发规范手册中，就明确禁止用这种方式来新建线程池。<br>原因是什么呢？<br>主要有以下三个原因：</p><ul><li>无界队列。<code>Executors.newFixedThreadPool</code>固定容量线程池和<code>Executors.newSingleThreadExecutor</code>单个容量线程池都会创建一个无界的队列来支持任务提交。也就是说，只要不停的往线程池提交任务，这个任务队列就会不断变长。如果因一些意外问题导致任务处理速度完全跟不上提交速度，程序有堆溢出<code>（OutOfMemoryError）</code>的风险。</li><li>无限的线程对象。<code>Executors.newCachedThreadPool</code>会创建一个线程数量可以无限制增长的线程池，实际上该线程池的线程容量最大值是<code>Integer.MAX_VALUE</code>。这显然也是很有风险的事情，可能浪费大量线程资源，影响程序的效率。</li><li>配置不灵活问题：<code>Executors</code>工具类提供的方法创建的线程池，其线程数、队列策略等参数都是固定的，无法根据系统的实际需要进行调整。实际上，线程池的配置应该根据硬件条件，实际任务需求等灵活调整。</li></ul><p>所以，对于生产环境而言，禁止直接使用<code>Executors</code>工具类提供的方法创建线程池。而推荐直接通过<code>ThreadPoolExecutor</code>来创建线程池实例，或者使用<code>Spring</code>框架封装好的线程池。<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ThreadPoolExecutor手动创建线程池，并提交任务</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>,</span><br><span class="line">             <span class="number">50</span>,</span><br><span class="line">             <span class="number">600L</span>,</span><br><span class="line">             TimeUnit.SECONDS,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">200</span>),</span><br><span class="line">             r -&gt; &#123;</span><br><span class="line">                 <span class="comment">// 创建并返回自定义的线程对象</span></span><br><span class="line">                 <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                 <span class="comment">// 设置线程名称</span></span><br><span class="line">                 thread.setName(<span class="string">&quot;Thread-&quot;</span> + r.hashCode());</span><br><span class="line">                 <span class="comment">// 设置线程优先级（最大值：10）</span></span><br><span class="line">                 thread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">                 <span class="comment">// 设置线程的守护状态</span></span><br><span class="line">                 thread.setDaemon(<span class="literal">false</span>);</span><br><span class="line">                 <span class="comment">// 返回新线程</span></span><br><span class="line">                 <span class="keyword">return</span> thread;</span><br><span class="line">             &#125;,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">             </span><br><span class="line">     <span class="comment">//提交任务</span></span><br><span class="line">     <span class="comment">//提交Runnable任务</span></span><br><span class="line">     threadPoolExecutor1.submit(() -&gt; System.out.println(<span class="string">&quot;你好朋友！&quot;</span>));</span><br><span class="line">     <span class="comment">//提交Callable任务</span></span><br><span class="line">     System.out.println(threadPoolExecutor1.submit(() -&gt; <span class="string">&quot;你好呀朋友！！&quot;</span>).get());</span><br></pre></td></tr></table></figure></p><h2 id="SpringBoot配置使用线程池"><a href="#SpringBoot配置使用线程池" class="headerlink" title="SpringBoot配置使用线程池"></a><code>SpringBoot</code>配置使用线程池</h2><p><code>Spring</code>框架也基于<code>ThreadPoolExecutor</code>封装了一个线程池，在<code>Spring</code>框架的应用中的使用上更加简便。</p><ol><li>使用<code>SpringBoot</code>默认自带的线程池<ul><li>在启动类上加上<code>@EnableAsync</code></li><li>在需要异步处理的方法上加上<code>@Async</code>注解即可开启该方法的异步处理。</li></ul></li><li>直接注入<code>ThreadPoolTaskExecutor</code>组件，该组件是<code>Spring</code>框架在加载容器的时候自动创建并注册到容器中的。可以直接使用这个组件往<code>Spring</code>自带的线程池中提交任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPoolApplicationTestsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ThreadPoolApplicationTestsService</span> &#123;</span><br><span class="line">    <span class="comment">//直接注入即可使用</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ThreadPoolTaskExecutor threadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//往Spring自带的线程池中提交任务，获得返回结果，并打印</span></span><br><span class="line">        System.out.println(threadPoolTaskExecutor.submit(() -&gt; <span class="string">&quot;你好呀小朋友！！&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//往Spring自带的线程池中提交任务，获得返回结果，并打印</span></span><br><span class="line">        System.out.println(threadPoolTaskExecutor.submit(() -&gt; <span class="string">&quot;你好呀大朋友！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>自己配置一个线程池。这里利用<code>SpringBoot</code>的自动装配的功能，配置一个自定义的线程池，并注册到容器中，供其他的组件注入使用。<ol><li>在配置文件中配置好相应的配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  task.pool.corePoolSize=50</span></span><br><span class="line"><span class="comment">#  task.pool.maxPoolSize=100</span></span><br><span class="line"><span class="comment">#  task.pool.keepAliveSeconds=3000</span></span><br><span class="line"><span class="comment">#  task.pool.queueCapacity=100</span></span><br><span class="line"><span class="attr">task:</span></span><br><span class="line">  <span class="attr">pool:</span></span><br><span class="line">    <span class="attr">core-size:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">keep-alive:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">queue-capacity:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></li><li>写一个读取配置文件中相应配置的参数配置类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzjw.marketweixin.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程池参数类</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 2023/09/21 09:55</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;task.pool&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> keepAlive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>写一个线程池配置类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzjw.marketweixin.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程池配置类</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 2023/09/21 09:59</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ThreadPoolProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExecutePool</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolProperties threadPoolProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改默认线程池的配置,将自定义的线程池注册到容器中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ThreadPoolTaskExecutor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">myThreadPoolTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">         <span class="comment">// 核心线程数</span></span><br><span class="line">         executor.setCorePoolSize(threadPoolProperties.getCoreSize());</span><br><span class="line">         <span class="comment">// 最大线程数</span></span><br><span class="line">         executor.setMaxPoolSize(threadPoolProperties.getMaxSize());</span><br><span class="line">         <span class="comment">// 非核心线程活跃时间</span></span><br><span class="line">         executor.setKeepAliveSeconds(threadPoolProperties.getKeepAlive());</span><br><span class="line">         <span class="comment">// 队列容量</span></span><br><span class="line">         executor.setQueueCapacity(threadPoolProperties.getQueueCapacity());</span><br><span class="line">         <span class="comment">// 设置线程的前缀名</span></span><br><span class="line">         executor.setThreadNamePrefix(<span class="string">&quot;market&quot;</span>);</span><br><span class="line">         <span class="comment">// 设置拒绝策略</span></span><br><span class="line">         executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">         <span class="comment">// 是否在任务执行完后关闭线程池</span></span><br><span class="line">         executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">false</span>);</span><br><span class="line">         <span class="comment">//初始化</span></span><br><span class="line">         executor.initialize();</span><br><span class="line">         <span class="keyword">return</span> executor;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>到这里我们已将自定义的线程池注册到容器中，在容器的组件中注入该线程池就可以往线程池中提交任务并行处理。为了方便往线程池中提交任务，我们还可以写一个工具类，注册到容器中，简化提交任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzjw.marketweixin.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tzjw.marketweixin.config.TaskExecutePool;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.task.TaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用线程池的工具类</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 2023/09/21 10:25</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringThreadPoolUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   ThreadPoolTaskExecutor taskExecutor;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 往线程池中提交任务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> java.util.concurrent.Future&lt;T&gt;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Xiaobin</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2023/09/21 16:46</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submitTask</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> taskExecutor.submit(task);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Error submitting task to the thread pool.&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过上面的封装之后，我们后续只需要在项目中引入<code>SpringThreadPoolUtil</code>这个组件，调用其中的<code>submitTask</code>方法，传入一个<code>Callable</code>类型的任务就可以向线程池中提交任务，并获得返回值。具体的使用实例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeIndexServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HomeIndexService</span> &#123;</span><br><span class="line">   <span class="comment">//注入工具类对象</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   SpringThreadPoolUtil springThreadPoolUtil;</span><br><span class="line">      </span><br><span class="line">   <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getIndexData</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 使用线程池提交数据库查询任务</span></span><br><span class="line">       Future&lt;List&gt; adFuture = springThreadPoolUtil.submitTask(() -&gt; &#123;</span><br><span class="line">           <span class="type">MarketAdExample</span> <span class="variable">marketAdExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarketAdExample</span>();</span><br><span class="line">           marketAdExample.setOrderByClause(<span class="string">&quot;add_time desc&quot;</span>);</span><br><span class="line">           marketAdExample.createCriteria().andDeletedEqualTo(<span class="literal">false</span>);</span><br><span class="line">           <span class="keyword">return</span> marketAdMapper.selectByExample(<span class="keyword">new</span> <span class="title class_">MarketAdExample</span>());</span><br><span class="line">       &#125;); </span><br><span class="line">       <span class="comment">//解析</span></span><br><span class="line">       List&lt;MarketAd&gt; = adFuture.get();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于池化思想的理解</title>
      <link href="/2023/08/19/%E5%AF%B9%E4%BA%8E%E6%B1%A0%E5%8C%96%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/08/19/%E5%AF%B9%E4%BA%8E%E6%B1%A0%E5%8C%96%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="对于池化思想的理解"><a href="#对于池化思想的理解" class="headerlink" title="对于池化思想的理解"></a>对于池化思想的理解</h1><h2 id="什么是池化思想"><a href="#什么是池化思想" class="headerlink" title="什么是池化思想"></a>什么是池化思想</h2><p>池化技术（Pooling），我们平常所说的池化技术常用的有两个，一个是各种编程语言中用来进行资源管理的一种技术，还有一种是应用在深度学习中，用来降低卷积神经网络（CNN）或循环神经网络（RNN）中的特征图（Feature Map）的维度的一种技术。本文在讲的是第一种。</p><p>我们在各种计算机技术中，池化技术是一种常见的资源管理技术，它可以通过<strong>预先创建和维护一定数量的资源实例来提高系统的性能和可靠性</strong>。从字面意义上来理解“池化技术”最主要的就是一个“池”字，什么是“池”？可以理解为一个容器，用来装东西的容器，装什么东西？装各种我们常用的资源。在编程的过程中，我们有时候需要用到一些资源，我们需要向操作系统申请，或者我们需要创建，比如一些连接对象，或者线程对象。需要的时候创建，用完之后释放，这是以前我们的主要方式。但是有这样的一个问题，有一些资源的申请或对象的创建和销毁实际上是很耗费时间的，当系统的面对一个人申请创建的请求的时候没什么，但是当请求多起来的时候，系统的压力就会变得非常大，这时候就会出现系统的瓶颈。</p><p>我们想一下，我们在某些场景下需要频繁用到的一些资源对象，其实是有共同的特点的：他们的创建和销毁很麻烦，但是可能他们只是帮助我们完成某一些特定的功能的，具有通用性。这里的通用性如何理解？就比如我们每次创建线程对象执行某个任务，虽然每个任务是不同的，但是我们创建的用于执行该任务的线程对象其实是相同的；还有我们创建的数据库的连接对象用于和数据库建立连接，发送SQL语句给数据库执行并返回结果集，虽然每次发送的SQL语句是不一样的，但是我们创建的连接对象是一样的。基于这个前提我们就可以引用池化技术来进行优化。预先创建，将后面系统需要用到的某些资源预先创建一部分，而不是需要的时候才临时创建。然后，通过某个容器将预先创建创建的资源管理起来。当我们需要用到该资源的时候到池子中找我们已经创建好的，使用完之后将资源归还到池子中。这就是池化技术的主要内容。其实在这个过程中，还是有很多细节的东西可以继续探讨，比如：我们一开始应该预先创建多少个资源？如何对资源进行管理，比如监控池子中的资源的状态？如何到池子中申请又如何归还资源？资源被申请完后池子是否可以扩容，如何扩容？当池子的资源数量达到我们规定的上限，已经无法扩容的时候如何处理新的请求，等等。</p><h2 id="池化思想有什么优点"><a href="#池化思想有什么优点" class="headerlink" title="池化思想有什么优点"></a>池化思想有什么优点</h2><p>池化技术的优点：</p><ol><li><strong>提高性能：</strong>池化技术可以避免频繁地创建和销毁资源实例，因为我们不再是临时创建的资源，而是申请已经创建好的资源；另外通过池化技术，实现了资源的复用，从而减少了资源的开销和系统资源的消耗。这样可以提高系统的性能和响应速度。</li><li><strong>提高可靠性：</strong>池化技术可以监控资源实例的状态，如果资源实例出现异常或超时，池化技术会自动将其标记为无效实例，并重新创建新的实例。这样可以提高系统的可靠性和稳定性。</li><li><strong>节约资源：</strong>池化技术可以限制资源实例的数量，以避免过多的实例占用系统资源。这样可以节约资源，并提高系统的可扩展性和稳定性。比如在阿里巴巴编程规范中对于多线程的使用上面就提到，不要new 线程，而是通过线程池。这主要是因为，当无限制new线程，最终可能会导致将系统的资源消耗殆尽，造成程序的崩溃，而通过线程池，一方面复用线程对象，另一方面可以限制最大的线程数量，保证系统的稳定运行。</li><li><strong>简化开发：</strong>池化技术可以通过配置文件或代码来管理资源实例，不用每次都重复地创建资源实例，使得开发人员可以更加方便地使用资源实例，同时也减少了一些资源管理的复杂性。</li></ol><p>当然每一项技术都是有缺点的，池化技术在系统可能并不需要的时候，仍然时刻维护这些资源实例，这会占用一定的内存，并占用一定的性能。</p><h2 id="池化思想在工作中的应用场景"><a href="#池化思想在工作中的应用场景" class="headerlink" title="池化思想在工作中的应用场景"></a>池化思想在工作中的应用场景</h2><p><strong>对象池：</strong>比如字符串常量池，JVM在方法区维护一个字符串常量池，类似于缓存区，当创建字符串的时候先去字符串常量池中看是否已经有存在了，如果有则返回，如果没有就创建一个，加入到常量池中并返回。这样可以大大减少内存的开销，提高性能。</p><p><strong>线程池：</strong>用于管理和如用线程，预先创建一组线程对象，在有任务的时候到线程池中取一个线程对象执行任务，完成后还回。这样实现了线程对象的复用，提高执行的效率，并且可以更好的管理线程对象。</p><p><strong>数据库连接池：</strong>预先创建一组数据库连接对象，当需要用到数据库连接对象和数据库进行通信的时候，到池中取一个空闲的对象使用，完成后返还，这样实现了数据库连接对象的复用，提高了数据库访问的效率。</p>]]></content>
      
      
      <categories>
          
          <category> 面试八股文相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 池化思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于面向对象思想的理解</title>
      <link href="/2023/08/17/%E5%AF%B9%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/08/17/%E5%AF%B9%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是面向对象，谈谈你对于面向对象的理解。"><a href="#什么是面向对象，谈谈你对于面向对象的理解。" class="headerlink" title="什么是面向对象，谈谈你对于面向对象的理解。"></a>什么是面向对象，谈谈你对于面向对象的理解。</h2><p>面向对象是一种程序设计思想。当我们谈到面向对象的时候总是会谈到面共享过程。那怎么样理解面向过程，又怎么样理解面向对象呢？<br>其实很好理解，从我们拿到一个需求开始，我们同样想完成一个需求，面向过程的思想着重于完成这个需求的步骤过程，</p><ul><li>首先将这一个大的整体的需求细化分解成每个小的步骤</li><li>然后安排每个步骤要完成什么样的功能，以及如何完成这样的功能</li><li>最后就是将上面的步骤合理的安排其先后顺序，让其最后能够实现一开始的需求。</li></ul><p>而面向对象思想在面对一个需求的时候，</p><ul><li>首先想的是要完成这个需求功能，涉及到了那些对象，涉及了那些类，</li><li>这些类和对象要有什么属性和行为</li><li>这些类和对象之间要如何协作完成这样的一个需求。</li></ul><p>面向过程思想，先具体逻辑细节，后抽象问题整体；面向对象，先抽象问题整体，后具体逻辑细节，先考虑对象，然后考虑对象里面的行为和属性。在软件开发中，在宏观上，我们使用面向对象来把握事物之间复杂的关系，分析系统；在微观上，仍然是面向过程的。就比如我们抽象出一个类，但是深入到类里面的行为的时候，其实还是面向过程的。</p><p>面向对象的思想其实是来源于我们的现实世界。从宏观上来看，现实世界中的事物是由其内部状态，以及围绕其状态的运动规律组成，不同的事物相互联系、相互作用，组成了纷繁复杂的世界。有句话叫：人们应该按照世界原本的样子去认识和理解世界本身。程序世界作为现实世界的一种组成和延申，反映的正是人们对于现实世界的认识。</p><p>Java里面的面向对象的思想的理解<br>Java是一门面向对象的高级语言，面向对象语言的三大特点分别是封装、继承和多态。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>就是将一些属性和操作放到一起，将其看作一个整体。为什么要这么做？在软件设计里面，面向对象程序设计的一个重要的原则就是：高内聚，低耦合。这里说的就是类的设计的两个主要的特征：我们现实生活中说到任何一个事物，其大多数的行为都会使用、依赖于自己的一些重要的属性。比如我们描述一个学生，学生的几乎所有的行为里面都要使用或者依赖学号这样的一个属性，再比如我们描述一个鸡（你干嘛!哎呦~~ ^-^）,想一下，有关的行为大多都会使用一些诸如品种这样的属性。我们将这些高度相关的属性和操作放到一起，抽象出一个更高层次的东西，这就是类。在类里面的东西是具有高度相关性的，这就是高内聚。<br>在Java里面的类也是同样的规则 ：将数据和对数据的操作封装在一个类里，通过用访问权限修饰符控制外部对数据的访问（为什么要加上访问权限？想一下，如果这个类设计得足够优秀，所有在类里面的东西都是高度相关的，那么如果别人能够轻易地擅自修改，那么是不合理的）。这样的例子在Java里面有：比如我们的将所有的实体类属性设置成私有，只提供给外部公共的get&#x2F;set方法。<br>另外封装的作用还有可以对外屏蔽细节，比如工具类方法隐藏内部的细节，外部调用者无需关注内部实现，只需关注业务逻辑。</p><p>优点: 封装可以保护数据的完整性和安全性</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一个类可以继承另一个类的属性和方法，可以称对父类的扩展&#x2F;做出自己的改变，可以理解为站在前人的肩膀上继续前进。这其实也是很符合人们的认识的，前人已经有的我可以直接拿来用，别人已经完成的我可以不用再从头开始再完成一遍。用程序设计的话来说就是提高了代码的复用性。（虽然开玩笑说人类的本质是一个复读机，但我想这肯定不是指程序猿群体。因为电脑最擅长干的事情就是步骤明确的，重复执行的事情，所以程序员的思维就是，所有重复干的事情，都想让机器来干。说白了就是懒，懒人改变世界嘛）<br>通过继承我们还可以实现一个现有类的新特性，在不改变原有类的情况下，满足新的开发需求。Java中的类的继承其实更好的说法是扩展，子类继承的父类，得到了父类中的属性和行为，然后基于此，扩展子类自己的东西。<br>继承的优点:提高代码的复用性,扩展性</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>为什么要有多态？其实和封装、继承一样，有一个主要对目的，就是为了提高代码的复用性以及灵活性。<br>多态产生的前提是条件是：</p><ul><li>两个类存在继承关系，</li><li>并且子类必须重写父类的同名方法，</li><li>然后还要有父类引用指向子类对象。</li></ul><p>在这样的前提下，多态就是：调用相同的方法可以表现出多种形态（表现出多种不同的结果，原因就是是父类引用指向了子类对象，基于这个对象虽然引用类型相同，但实际运行时类型不相同，而调用方法体现行为是根据运行时类型来决定的）。</p><p>举例: 提供了一套统一的接口的程序设计模式，使得我们可以基于接口编程。比如在选用集合类的业务时，改变指向的子类集合对象不需要修改其它业务代码，</p><p>优点: 提高代码的灵活性，可扩展性</p>]]></content>
      
      
      <categories>
          
          <category> 面试八股文相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关Java的时间戳问题</title>
      <link href="/2023/08/16/%E6%9C%89%E5%85%B3java%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/"/>
      <url>/2023/08/16/%E6%9C%89%E5%85%B3java%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在做力扣的355题设计推特<br><a href="https://leetcode.cn/problems/design-twitter/description/">https://leetcode.cn/problems/design-twitter/description/</a><br>时，一个主要的功能是要倒序返回一个用户以及他的所关注用户的前十条推文列表。我的做法是设计一个推文类，该类里面有一个成员变量<code>createdTime</code>，在生成一个推文类的时候记录该类生成的时间戳。然后等到返回推文列表的时候用一个<code>TreeSet</code>容器，通过自定义排序规则来实现按照生成时间倒序返回的目的。其中涉及到Java里面的时间戳的生成。我一开始使用的是<code>System.currentTimeMillis()</code>方法，这个方法返回的是一个毫秒精度的时间戳。但是这样做是有问题的，会卡在：连续调用函数生成推文类的用例那里。当我将代码搬到idea上debug的时候，发现了一个诡异的事情，直接run的时候会出bug，连续生成的两个推文类到最后返回的时候会吞掉一个；但是用debug模式的时候，有时候是正确的输出，有时候又是和run模式一样的错误的输出。一开始我以为是idea的debug模式会比run模式多执行了一些方法的问题（比如idea在debug模式下会自动调用一些集合的<code>toString()</code>方法，用于在debug的时候看到集合里面的内容，但是在run模式下不会），但是后来找很久发现并不是这里面的问题。最后无奈求助了队友才发现是上面提到的推文类里面时间戳的精度不够的问题。</p><h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>Java里面的<code>System</code>包下的<code>currentTimeMillis()</code>，调用之后返回的是一个以毫秒为精度的时间戳，在Java的源码中该方法的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Returns the current time in milliseconds. Note that while the unit of time of the return value is a millisecond, the granularity of the value depends on the underlying operating system and may be larger. For example, many operating systems measure time in units of tens of milliseconds.</span></span><br><span class="line"><span class="comment">See the description of the class Date for a discussion of slight discrepancies that may arise between &quot;computer time&quot; and coordinated universal time (UTC).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">currentTimeMillis</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>该方法返回的是一个<code>long</code>类型的值，表示：当前时间与协调世界时1970年1月1日午夜之间的差值，以毫秒为单位。</p><p>但是：<code>System.currentTimeMillis()</code> 虽然返回值的时间单位是毫秒，但值的粒度取决于底层操作系统，在不同操作系统下的实际粒度是不同的。许多操作系统以数十毫秒为单位测量时间。比如：</p><ol><li><p><strong>Windows 系统：</strong> 在 Windows 操作系统中，默认情况下，<code>System.currentTimeMillis()</code> 的精度通常在 15 毫秒左右，即时间戳的更新间隔可能为 15 毫秒。这是因为 Windows 系统使用多媒体定时器（<code>Multimedia Timer</code>）来提供系统计时服务，而这个定时器的默认分辨率是 15 毫秒。</p></li><li><p><strong>Linux 系统：</strong> 在 Linux 操作系统中，<code>System.currentTimeMillis()</code> 的实际精度取决于硬件、内核版本和系统配置。一般情况下，Linux 的时间戳精度可以达到几毫秒甚至更低，特别是在支持高分辨率计时器（<code>High-Resolution Timer</code>）的系统上。高分辨率计时器允许纳秒级的时间戳，但是系统配置和硬件支持可能会影响其实际精度。在一些现代的 Linux 发行版中，内核已经支持高分辨率计时器。</p></li></ol><p>因此当发生连续的调用同一个方法的时候，两个方法执行时间之差小于该粒度，那么拿到的时间戳就是相同的，这就导致了后面在用<code>TreeSet</code>容器按照时间戳进行排序的时候会将其中一个去重处理，这就解释了上面的直接run会出错，但是debug模式下，在将断点打在方法内的时候，由于此时两个方法的调用时间被隔开了，因此这时拿到的时间戳就是不同的，进而没有问题的这一诡异现象。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>上面的问题是由于<code>System.currentTimeMillis()</code> 方法获取的时间戳粒度不够导致的，当连续两个方法调用的时间间隔小于该方法的粒度的时候，该方法拿到的是两个相同的时间戳，然后再使用<code>TreeSet</code>进行处理的时候，由于<code>TreeSet</code>容器的特性，会将时间戳相同的去重处理，因此解决方法也很简单，换一个更高精度的时间戳就可以了。一般认为达到纳秒级的时间精度就足以表示两个方法调用之间的最小时间间隔了，但是并不绝对，具体的还是要看不同的操作系统、硬件、方法调用开销以及可能的线程竞争等方面。但是在这里，我们只要将获取的时间戳的精度提高到纳秒级就可以了。</p><h1 id="Java的时间戳获取"><a href="#Java的时间戳获取" class="headerlink" title="Java的时间戳获取"></a>Java的时间戳获取</h1><p>一般我们获取时间戳的时候通常有以下这几种方式：</p><ol><li><p><code>System.currentTimeMillis()</code> 方法：返回的是一个<code>long</code>类型的值，表示：当前时间与协调世界时1970年1月1日午夜之间的差值，以毫秒为单位。</p></li><li><p><code>new Date().getTime()</code>方法：该方法的底层其实还是调用的<code>System.currentTimeMillis()</code> 方法，其源码如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Calendar.getInstance().getTimeInMillis()</code>方法：也是返回此日历的时间值（以毫秒为单位）。</p></li></ol><p>上面的三个返回的都是以毫秒值为单位的时间戳，但是他们在效率上还是有差异的：</p><ul><li><code>System.currentTimeMillis()</code> 方法是调用本地方法，且是静态方法，不需要创建对象，因此是最快的；</li><li>通过<code>new Date().getTime()</code>方法获取时间戳，它的底层还是调用的<code>System.currentTimeMillis()</code> 方法，但是要创建Date对象，因此效率比不上<code>System.currentTimeMillis()</code> ；</li><li><code>Calendar.getInstance().getTimeInMillis()</code>方法由于考虑的因素比较多（比如考虑了时区的影响）因此在效率上表现最差。</li></ul><h1 id="精度更高的时间戳的获取"><a href="#精度更高的时间戳的获取" class="headerlink" title="精度更高的时间戳的获取"></a>精度更高的时间戳的获取</h1><p>上面的三种获取时间戳的方法都是只能获取到毫秒精度的时间戳，这里的毫秒级精度并不是说两个值之间最小相差1毫秒，事实上有些系统的粒度甚至是几十毫秒。那我们想要获取到精度更高的时间戳（比如纳秒级的精度的时间戳）怎么办呢？</p><p>下面介绍两个我目前知道的方法。</p><h2 id="通过System-nanoTime-方法"><a href="#通过System-nanoTime-方法" class="headerlink" title="通过System.nanoTime()方法"></a>通过System.nanoTime()方法</h2><p>在System类的<code>currentTimeMillis()</code>这个方法的下面紧接着就定义着一个<code>nanoTime()</code>方法，该方法返回的是当前时间与某个特定起点时间之间的纳秒数差。它通常用于计算不同时间片段之间的时间差，而不是作为全局唯一的时间戳。在源码中是这样定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Returns the current value of the running Java Virtual Machine&#x27;s high-resolution time source, in nanoseconds.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time. The value returned represents nanoseconds since some fixed but arbitrary origin time (perhaps in the future, so values may be negative). The same origin is used by all invocations of this method in an instance of a Java virtual machine; other virtual machine instances are likely to use a different origin.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This method provides nanosecond precision, but not necessarily nanosecond resolution (that is, how frequently the value changes) - no guarantees are made except that the resolution is at least as good as that of currentTimeMillis().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Differences in successive calls that span greater than approximately 292 years (263 nanoseconds) will not correctly compute elapsed time due to numerical overflow.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The values returned by this method become meaningful only when the difference between two such values, obtained within the same instance of a Java virtual machine, is computed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">For example, to measure how long some code takes to execute:</span></span><br><span class="line"><span class="comment">  long startTime = System.nanoTime();   // ... the code being measured ...   </span></span><br><span class="line"><span class="comment">  long estimatedTime = System.nanoTime() - startTime;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">To compare two nanoTime values</span></span><br><span class="line"><span class="comment">  long t0 = System.nanoTime();   ...   </span></span><br><span class="line"><span class="comment">  long t1 = System.nanoTime();</span></span><br><span class="line"><span class="comment">one should use t1 - t0 &lt; 0, not t1 &lt; t0, because of the possibility of numerical overflow.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nanoTime</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>根据上面的定义的注释，在使用这个方法之前要注意以下的几个方面：</p><ol><li>关于返回值：返回正在运行的Java虚拟机的高分辨率时间源的当前值，单位为纳秒。但是和<code>currentTimeMillis()</code>一样，虽然是纳秒级的精度，但并不意味着最小两个值之间的差是1纳秒。除了保证能提供比<code>currentTimeMillis()</code>方法更高的精度之外，并不保证返回的两个值之间的任何关系。</li><li>这种方法只能用于测量经过的时间，与系统或挂钟时间的任何其他概念无关。返回的值表示自某个固定但任意的起始时间（时间原点）以来的纳秒（可能在将来，因此值可能为负数）。在Java虚拟机的实例中，此方法的所有调用都使用相同的原点；其他虚拟机实例可能使用不同的来源。</li><li>由于数值溢出的问题，跨度超过约292年，或者小于263纳秒的连续调用之间的差异将无法正确计算所用时间。</li></ol><h2 id="java-time-包下的-Instant-类"><a href="#java-time-包下的-Instant-类" class="headerlink" title="java.time 包下的 Instant 类"></a>java.time 包下的 <code>Instant</code> 类</h2><p>Java 8 引入的 <code>java.time</code> 包提供了更强大且易于使用的工具。<code>Instant</code> 类是其中的一部分，用于表示时间轴上的一个特定瞬时点，而且提供了以毫秒和纳秒为单位的时间戳。下面我将详细介绍 <code>Instant</code> 类的创建、使用以及与其他方法的对比。</p><h3 id="创建-Instant-实例："><a href="#创建-Instant-实例：" class="headerlink" title="创建 Instant 实例："></a><strong>创建 Instant 实例：</strong></h3><p> 创建 <code>Instant</code> 实例非常简单，可以使用静态方法 <code>Instant.now()</code> 获取当前的时间点。也可以通过提供秒数和纳秒数来创建一个特定的瞬时点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间的 Instant</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定时间点的 Instant</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">specificInstant</span> <span class="operator">=</span> Instant.ofEpochSecond(seconds, nanos);</span><br></pre></td></tr></table></figure><h3 id="获取时间戳："><a href="#获取时间戳：" class="headerlink" title="获取时间戳："></a><strong>获取时间戳：</strong></h3><p><code>Instant</code> 实例提供了两种方式获取时间戳，分别是毫秒值和纳秒值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">timestampMillis</span> <span class="operator">=</span> instant.toEpochMilli(); <span class="comment">// 获取毫秒级别的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">timestampNanos</span> <span class="operator">=</span> instant.getNano(); <span class="comment">// 获取纳秒级别的时间戳</span></span><br></pre></td></tr></table></figure><h3 id="与其他方法的对比："><a href="#与其他方法的对比：" class="headerlink" title="与其他方法的对比："></a><strong>与其他方法的对比：</strong></h3><p><code>Instant</code> 类在 <code>java.time</code> 包中是一个非常有用的工具，用于表示高精度的时间戳和瞬时点。它在许多方面比传统的时间处理方法更优越，尤其是在精度、易用性和线程安全性方面。在与其他时间处理方法对比时，<code>Instant</code> 类在精度和易用性方面都有优势。</p><ul><li>与 <code>System.currentTimeMillis()</code> 对比：<code>Instant</code> 类提供了更高精度的时间戳，可以获取纳秒级别的时间戳，而不仅仅是毫秒。同时，<code>Instant</code> 是不依赖于操作系统精度的。</li><li>与 <code>System.nanoTime()</code> 对比：<code>Instant</code> 类的 <code>getNano()</code> 方法可以用来获取当前纳秒值，类似于 <code>System.nanoTime()</code>，但需要注意 <code>System.nanoTime()</code> 更适合用于测量时间间隔，而不是绝对时间点。</li><li>与 <code>Date</code> 和 <code>Calendar</code> 对比：<code>Instant</code> 是 <code>java.time</code> 包的一部分，与传统的 <code>Date</code> 和 <code>Calendar</code> 相比，它更加现代且线程安全，同时提供了更好的易用性和精度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 时间戳 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
